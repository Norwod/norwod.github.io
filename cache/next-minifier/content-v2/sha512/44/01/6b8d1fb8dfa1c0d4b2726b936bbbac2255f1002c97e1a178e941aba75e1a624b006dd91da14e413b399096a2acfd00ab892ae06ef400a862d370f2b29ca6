{"code":"(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[26],{\"//ZD\":function(t,e,n){\"use strict\";var o;n.d(e,\"a\",(function(){return o})),function(t){t.INDEX=\"/\",t.MOHITO=\"/mohito\",t.TROPICAL=\"/tropical\",t.ORANGE_LEMONADE=\"/orange_lemonade\",t.MINT_MILK=\"/mint_milk\",t.ICEBERG=\"/iceberg\",t.CHOKOMILK=\"/chokomilk\",t.SLAD=\"/slad\",t.CHAMP=\"/champ\",t.ALE=\"/ale\",t.KLEMENT=\"/klement\",t.PROSTUDA=\"/prostuda\",t.GOGOL=\"/gogol\"}(o||(o={}))},KdaB:function(t,e,n){\"use strict\";n.r(e),n.d(e,\"Root\",(function(){return B}));var o=n(\"cDcd\"),i=n.n(o),a=n(\"weFX\");!function(){if(\"navigate\"in window)return;const t={37:\"left\",38:\"up\",39:\"right\",40:\"down\"};let e=null,n=null,o={element:null,rect:null},i=null;function a(){window.addEventListener(\"keydown\",(o=>{const i=parent&&parent.__spatialNavigation__&&parent.__spatialNavigation__.keyMode||window.__spatialNavigation__&&window.__spatialNavigation__.keyMode,a=document.activeElement,l=t[o.keyCode];if(9===o.keyCode&&(n=null),!(!i||\"NONE\"===i||\"SHIFTARROW\"===i&&!o.shiftKey||\"ARROW\"===i&&o.shiftKey||o.ctrlKey||o.metaKey||o.altKey)&&!o.defaultPrevented){let i={left:!0,up:!0,right:!0,down:!0};\"INPUT\"!==a.nodeName&&\"TEXTAREA\"!==a.nodeName||(i=function(e){const n=[\"email\",\"date\",\"month\",\"number\",\"time\",\"week\"],o=[\"password\",\"text\",\"search\",\"tel\",\"url\",null],i=document.activeElement,a=i.selectionStart,r=i.selectionEnd,l={left:!1,up:!1,right:!1,down:!1},c=t[e.keyCode];if(void 0===c)return l;(!n.includes(i.getAttribute(\"type\"))||\"up\"!==c&&\"down\"!==c)&&(o.includes(i.getAttribute(\"type\"))||\"TEXTAREA\"===i.nodeName)?a===r&&(0===a&&(l.left=!0,l.up=!0),r===i.value.length&&(l.right=!0,l.down=!0)):l[c]=!0;return l}(o)),i[l]&&(o.preventDefault(),e=new Map,r(l),e=null,n=null)}})),document.addEventListener(\"mouseup\",(t=>{n={x:t.clientX,y:t.clientY}})),window.addEventListener(\"focusin\",(t=>{t.target!==window&&(o.element=t.target,o.rect=t.target.getBoundingClientRect())}))}function r(t){const e=function(){let t=document.activeElement;if(!t||t===document.body&&!document.querySelector(\":focus\")){if(o.element&&t!==o.element){const e=window.getComputedStyle(o.element,null),n=[\"hidden\",\"collapse\"];if(o.element.disabled||n.includes(e.getPropertyValue(\"visibility\")))return t=o.element,t}t=document.documentElement}!o.element||0!==G(o.element).height&&0!==G(o.element).width||(n=(o.left+o.right)/2,o.top,o.bottom);if(!S(t)){const e=h(t);if(e&&e===window)return e}return t}();let i=e,a=null;n&&(a=document.elementFromPoint(n.x,n.y),null===a&&(a=document.body),_(a)&&!E(a)?n=null:i=E(a)?a:a.getSpatialNavigationContainer()),i!==window&&i!==document&&i!==document.documentElement||(i=document.body||document.documentElement);let r=null;if((E(i)||\"BODY\"===i.nodeName)&&\"INPUT\"!==i.nodeName){\"IFRAME\"===i.nodeName&&(i=i.contentDocument.documentElement),r=r===window?document.body:i;let n=null;if(document.activeElement===e||document.activeElement===document.body&&e===document.documentElement){if(n=i.spatialNavigationSearch(t,{container:i,candidates:u(i,{mode:\"all\"})}),l(n,t))return}else r=r.getSpatialNavigationContainer()}r=i.getSpatialNavigationContainer();let c=r.parentElement?r.getSpatialNavigationContainer():null;c||window.location===window.parent.location||(c=window.parent.document.documentElement),v(i,r,c,t,\"all\")}function l(t,e){if(t){if(!b(\"beforefocus\",t,null,e))return!0;const o=t.getSpatialNavigationContainer();return o!==window?t.focus():t.focus({preventScroll:!0}),n=null,!0}return!1}function c(t,e){return N(t,e)&&!M(t,e)?(x(t,e),!0):!t.parentElement&&!T(t,e)&&(x(t.ownerDocument.documentElement,e),!0)}function u(t,e={mode:\"visible\"}){let n=[];if(t.childElementCount>0){t.parentElement||(t=t.getElementsByTagName(\"body\")[0]||document.body);const e=t.children;for(const t of e)O(t)?n.push(t):_(t)?(n.push(t),!E(t)&&t.childElementCount&&(n=n.concat(u(t,{mode:\"all\"})))):t.childElementCount&&(n=n.concat(u(t,{mode:\"all\"})))}return\"all\"===e.mode?n:n.filter(B)}function d(t,e,n,o){const i=t;return o=o||i.getSpatialNavigationContainer(),f(i,n=!n||n.length<=0?u(o):n,e,o)}function s(t,e){const o=this;let i,a=[],r=[],l=function(t){const e=t.getSpatialNavigationContainer().focusableAreas(),n=[];return e.forEach((e=>{t!==e&&k(e,t)&&n.push(e)})),n}(o);e||(e={});const c=o.getSpatialNavigationContainer();let s=u(c);const f=e.container||c;e.container&&c.contains(e.container)&&(s=s.concat(u(f)));const p=e.candidates&&e.candidates.length>0?e.candidates.filter((t=>f.contains(t))):s.filter((t=>f.contains(t)&&f!==t));if(p&&p.length>0){p.forEach((t=>{t!==o&&(o.contains(t)&&o!==t?a:r).push(t)}));let e=l.filter((t=>!a.includes(t))),c=p.filter((t=>E(t)&&k(o,t))).map((t=>t.focusableAreas())).flat().filter((t=>t!==o));if(a=a.concat(e).filter((t=>f.contains(t))),r=r.concat(c).filter((t=>f.contains(t))),r.length>0&&(r=d(o,t,r,f)),a&&a.length>0&&\"INPUT\"!==o.nodeName&&(i=function(t,e,o){return g(t,e,o,n?F:H)}(o,a,t)),i=i||m(o,r,t),i&&O(i)){const e=u(i,{mode:\"all\"}),n=e.length>0?o.spatialNavigationSearch(t,{candidates:e,container:i}):null;n?i=n:_(i)||(p.splice(p.indexOf(i),1),i=p.length?o.spatialNavigationSearch(t,{candidates:p,container:f}):null)}return i}return null}function f(t,e,n,o){const i=t.getSpatialNavigationContainer();let a;return void 0===n?e:(a=i.parentElement&&o!==i&&!B(t)?G(i):G(t),!E(t)&&\"BODY\"!==t.nodeName||\"INPUT\"===t.nodeName?e.filter((e=>{const i=G(e),r=\"IFRAME\"===e.nodeName?e.contentDocument.body:null;return o.contains(e)&&e!==t&&r!==t&&D(i,a,n)&&!j(a,i)})):e.filter((e=>{const i=G(e);return o.contains(e)&&(t.contains(e)&&j(a,i)&&e!==t||D(i,a,n))})))}function m(t,e,n){const o=t.getSpatialNavigationContainer(),i=getComputedStyle(o).getPropertyValue(\"--spatial-navigation-function\"),a=G(t);let r,l;switch(i){case\"grid\":l=e.filter((t=>R(a,G(t),n))),l.length>0&&(e=l),r=U;break;default:r=K}return g(t,e,n,r)}function g(t,e,n,o){let i=null;window.location===window.parent.location||\"BODY\"!==t.nodeName&&\"HTML\"!==t.nodeName?i=t.getBoundingClientRect():(i=window.frameElement.getBoundingClientRect(),i.x=0,i.y=0);let a=Number.POSITIVE_INFINITY,r=[];if(e)for(let l=0;l<e.length;l++){const t=o(i,G(e[l]),n);t<a?(a=t,r=[e[l]]):t===a&&r.push(e[l])}return 0===r.length?null:r.length>1&&o===U?g(t,r,n,V):r[0]}function p(){let t=this;do{if(!t.parentElement){t=window.location!==window.parent.location?window.parent.document.documentElement:window.document.documentElement;break}t=t.parentElement}while(!E(t));return t}function h(t){let e=t;do{if(!e.parentElement){e=window.location!==window.parent.location?window.parent.document.documentElement:window.document.documentElement;break}e=e.parentElement}while(!C(e)||!B(e));return e!==document&&e!==document.documentElement||(e=window),e}function w(t={mode:\"visible\"}){const e=this.parentElement?this:document.body,n=Array.prototype.filter.call(e.getElementsByTagName(\"*\"),_);return\"all\"===t.mode?n:n.filter(B)}function b(t,e,n,o){if([\"beforefocus\",\"notarget\"].includes(t)){const i=new CustomEvent(\"nav\"+t,{bubbles:!0,cancelable:!0,detail:{causedTarget:n,dir:o}});return e.dispatchEvent(i)}}function y(t,e){return getComputedStyle(t).getPropertyValue(`--${e}`).trim()}function v(t,e,n,o,i){let a={candidates:u(e,{mode:i}),container:e};for(;n;){if(l(t.spatialNavigationSearch(o,a),o))return;if(\"visible\"===i&&c(e,o))return;{if(!b(\"notarget\",e,t,o))return;e===document||e===document.documentElement?window.location!==window.parent.location&&(e=(t=window.frameElement).ownerDocument.documentElement):e=n,a={candidates:u(e,{mode:i}),container:e};let r=e.getSpatialNavigationContainer();n=r!==e?r:null}}a={candidates:u(e,{mode:i}),container:e},!n&&e&&l(t.spatialNavigationSearch(o,a),o)||b(\"notarget\",a.container,t,o)}function x(t,e,n=0){if(t)switch(e){case\"left\":t.scrollLeft-=40+n;break;case\"right\":t.scrollLeft+=40+n;break;case\"up\":t.scrollTop-=40+n;break;case\"down\":t.scrollTop+=40+n}}function E(t){return!t.parentElement||\"IFRAME\"===t.nodeName||C(t)||function(t){return\"contain\"===y(t,\"spatial-navigation-contain\")}(t)}function O(t){return\"delegable\"===y(t,\"spatial-navigation-contain\")}function C(t){const e=window.getComputedStyle(t,null),n=e.getPropertyValue(\"overflow-x\"),o=e.getPropertyValue(\"overflow-y\");return!!(\"visible\"!==n&&\"clip\"!==n&&P(t,\"left\")||\"visible\"!==o&&\"clip\"!==o&&P(t,\"down\"))}function N(t,e){if(t&&\"object\"===typeof t){if(e&&\"string\"===typeof e){if(P(t,e)){const n=window.getComputedStyle(t,null),o=n.getPropertyValue(\"overflow-x\"),i=n.getPropertyValue(\"overflow-y\");switch(e){case\"left\":case\"right\":return\"visible\"!==o&&\"clip\"!==o&&\"hidden\"!==o;case\"up\":case\"down\":return\"visible\"!==i&&\"clip\"!==i&&\"hidden\"!==i}}return!1}return\"HTML\"===t.nodeName||\"BODY\"===t.nodeName||C(t)&&P(t)}}function P(t,e){if(t&&\"object\"===typeof t){if(!e||\"string\"!==typeof e)return t.scrollWidth>t.clientWidth||t.scrollHeight>t.clientHeight;switch(e){case\"left\":case\"right\":return t.scrollWidth>t.clientWidth;case\"up\":case\"down\":return t.scrollHeight>t.clientHeight}return!1}}function T(t,e){let n=!1;switch(e){case\"left\":n=0===t.scrollLeft;break;case\"right\":n=t.scrollWidth-t.scrollLeft-t.clientWidth===0;break;case\"up\":n=0===t.scrollTop;break;case\"down\":n=t.scrollHeight-t.scrollTop-t.clientHeight===0}return n}function M(t,e){if(N(t,e)){const n=t.scrollTop,o=t.scrollLeft,i=t.scrollHeight-t.clientHeight,a=t.scrollWidth-t.clientWidth;switch(e){case\"left\":return 0===o;case\"right\":return Math.abs(o-a)<=1;case\"up\":return 0===n;case\"down\":return Math.abs(n-i)<=1}}return!1}function S(t){const e=t.getBoundingClientRect();let n=h(t),o=null;return o=n!==window?G(n):new DOMRect(0,0,window.innerWidth,window.innerHeight),!(!j(o,e)||!j(o,e))}function _(t){return!(t.tabIndex<0||function(t){return\"A\"===t.tagName&&null===t.getAttribute(\"href\")&&null===t.getAttribute(\"tabIndex\")}(t)||function(t){return!![\"BUTTON\",\"INPUT\",\"SELECT\",\"TEXTAREA\",\"OPTGROUP\",\"OPTION\",\"FIELDSET\"].includes(t.tagName)&&t.disabled}(t)||function(t){return t.inert&&!t.ownerDocument.documentElement.inert}(t)||!function(t){return!!A(t.parentElement)&&!(!A(t)||\"0\"===t.style.opacity||\"0px\"===window.getComputedStyle(t).height||\"0px\"===window.getComputedStyle(t).width)}(t))&&(!!(!t.parentElement||N(t)&&P(t)||t.tabIndex>=0)||void 0)}function B(t){return!t.parentElement||A(t)&&function(t){const e=G(t);if(\"IFRAME\"!==t.nodeName&&(e.top<0||e.left<0||e.top>t.ownerDocument.documentElement.clientHeight||e.left>t.ownerDocument.documentElement.clientWidth))return!1;let n=parseInt(t.offsetWidth)/10,o=parseInt(t.offsetHeight)/10;n=isNaN(n)?1:n,o=isNaN(o)?1:o;const i={middle:[(e.left+e.right)/2,(e.top+e.bottom)/2],leftTop:[e.left+n,e.top+o],rightBottom:[e.right-n,e.bottom-o]};for(const a in i){const e=t.ownerDocument.elementFromPoint(...i[a]);if(t===e||t.contains(e))return!0}return!1}(t)}function k(t,e){const n=G(t),o=G(e||t.getSpatialNavigationContainer());return!(n.left<o.left||n.right>o.right||n.top<o.top||n.bottom>o.bottom)}function A(t){const e=window.getComputedStyle(t,null),n=e.getPropertyValue(\"visibility\");return\"none\"!==e.getPropertyValue(\"display\")&&![\"hidden\",\"collapse\"].includes(n)}function j(t,e){const n=t.left<e.right&&t.right>=e.right,o=t.left<=e.left&&t.right>e.left,i=t.top<=e.top&&t.bottom>e.top,a=t.top<e.bottom&&t.bottom>=e.bottom;return(n||o)&&(i||a)}function D(t,e,n){switch(n){case\"left\":return L(e,t);case\"right\":return L(t,e);case\"up\":return I(e,t);case\"down\":return I(t,e);default:return!1}}function L(t,e){return t.left>=e.right||t.left>=e.left&&t.right>e.right&&t.bottom>e.top&&t.top<e.bottom}function I(t,e){return t.top>=e.bottom||t.top>=e.top&&t.bottom>e.bottom&&t.left<e.right&&t.right>e.left}function R(t,e,n){switch(n){case\"left\":case\"right\":return t.bottom>e.top&&t.top<e.bottom;case\"up\":case\"down\":return t.right>e.left&&t.left<e.right;default:return!1}}function F(t,e,o){const i=W(o,n,e),a=Math.abs(i.entryPoint.x-i.exitPoint.x),r=Math.abs(i.entryPoint.y-i.exitPoint.y);return Math.sqrt(Math.pow(a,2)+Math.pow(r,2))}function H(t,e,n){const o={left:\"right\",right:\"left\",up:\"bottom\",down:\"top\"}[n];return Math.abs(t[o]-e[o])}function K(t,e,n){let o=0,i=0;const a=W(n,t,e),r=Math.abs(a.entryPoint.x-a.exitPoint.x),l=Math.abs(a.entryPoint.y-a.exitPoint.y),c=Math.sqrt(Math.pow(r,2)+Math.pow(l,2));let u,d;const s=function(t,e){const n={width:0,height:0,area:0},o=[Math.max(t.left,e.left),Math.max(t.top,e.top)],i=[Math.min(t.right,e.right),Math.min(t.bottom,e.bottom)];n.width=Math.abs(o[0]-i[0]),n.height=Math.abs(o[1]-i[1]),o[0]>=i[0]||o[1]>=i[1]||(n.area=Math.sqrt(n.width*n.height));return n}(t,e),f=s.area;switch(n){case\"left\":case\"right\":R(t,e,n)?i=Math.min(s.height/t.height,1):o=t.height/2,u=30*(l+o),d=5*i;break;case\"up\":case\"down\":R(t,e,n)?i=Math.min(s.width/t.width,1):o=t.width/2,u=2*(r+o),d=5*i;break;default:u=0,d=0}return c+u-d-f}function V(t,e,n){const o=W(n,t,e),i=Math.abs(o.entryPoint.x-o.exitPoint.x),a=Math.abs(o.entryPoint.y-o.exitPoint.y);return Math.sqrt(Math.pow(i,2)+Math.pow(a,2))}function U(t,e,n){const o=W(n,t,e);return\"left\"===n||\"right\"===n?Math.abs(o.entryPoint.x-o.exitPoint.x):Math.abs(o.entryPoint.y-o.exitPoint.y)}function W(t=\"down\",e,o){const i={entryPoint:{x:0,y:0},exitPoint:{x:0,y:0}};if(n){switch(i.exitPoint=e,t){case\"left\":i.entryPoint.x=o.right;break;case\"up\":i.entryPoint.y=o.bottom;break;case\"right\":i.entryPoint.x=o.left;break;case\"down\":i.entryPoint.y=o.top}switch(t){case\"left\":case\"right\":n.y<=o.top?i.entryPoint.y=o.top:n.y<o.bottom?i.entryPoint.y=n.y:i.entryPoint.y=o.bottom;break;case\"up\":case\"down\":n.x<=o.left?i.entryPoint.x=o.left:n.x<o.right?i.entryPoint.x=n.x:i.entryPoint.x=o.right}}else{switch(t){case\"left\":i.exitPoint.x=e.left,i.entryPoint.x=o.right<e.left?o.right:e.left;break;case\"up\":i.exitPoint.y=e.top,i.entryPoint.y=o.bottom<e.top?o.bottom:e.top;break;case\"right\":i.exitPoint.x=e.right,i.entryPoint.x=o.left>e.right?o.left:e.right;break;case\"down\":i.exitPoint.y=e.bottom,i.entryPoint.y=o.top>e.bottom?o.top:e.bottom}switch(t){case\"left\":case\"right\":I(e,o)?(i.exitPoint.y=e.top,i.entryPoint.y=o.bottom<e.top?o.bottom:e.top):I(o,e)?(i.exitPoint.y=e.bottom,i.entryPoint.y=o.top>e.bottom?o.top:e.bottom):(i.exitPoint.y=Math.max(e.top,o.top),i.entryPoint.y=i.exitPoint.y);break;case\"up\":case\"down\":L(e,o)?(i.exitPoint.x=e.left,i.entryPoint.x=o.right<e.left?o.right:e.left):L(o,e)?(i.exitPoint.x=e.right,i.entryPoint.x=o.left>e.right?o.left:e.right):(i.exitPoint.x=Math.max(e.left,o.left),i.entryPoint.x=i.exitPoint.x)}}return i}function G(t){let n=e&&e.get(t);if(!n){const o=t.getBoundingClientRect();n={top:Number(o.top.toFixed(2)),right:Number(o.right.toFixed(2)),bottom:Number(o.bottom.toFixed(2)),left:Number(o.left.toFixed(2)),width:Number(o.width.toFixed(2)),height:Number(o.height.toFixed(2))},e&&e.set(t,n)}return n}function z(t){const e=window.__spatialNavigation__&&window.__spatialNavigation__.keyMode;window.__spatialNavigation__=!1===t?Y():Object.assign(Y(),function(){function t(t,e){return N(t,e)&&!M(t,e)||!t.parentElement&&!T(t,e)}function e(e,n,o,i){let a=n,r=null;if(a!==document&&a!==document.documentElement||(a=document.body||document.documentElement),(E(a)||\"BODY\"===a.nodeName)&&\"INPUT\"!==a.nodeName){\"IFRAME\"===a.nodeName&&(a=a.contentDocument.body);const n=u(a,i);if(Array.isArray(n)&&n.length>0)return e?d(a,o,n):a.spatialNavigationSearch(o,{candidates:n});if(t(a,o))return e?[]:a}let l=a.getSpatialNavigationContainer(),c=l.parentElement?l.getSpatialNavigationContainer():null;for(c||window.location===window.parent.location||(c=window.parent.document.documentElement);c;){const n=f(a,u(l,i),o,l);if(Array.isArray(n)&&n.length>0){if(r=a.spatialNavigationSearch(o,{candidates:n,container:l}),r)return e?n:r}else{if(t(l,o))return e?[]:a;if(l===document||l===document.documentElement){if(l=window.document.documentElement,window.location!==window.parent.location){if(a=window.frameElement,l=window.parent.document.documentElement,!l.parentElement){c=null;break}c=l.getSpatialNavigationContainer()}}else{if(_(l)&&(a=l),l=c,!l.parentElement){c=null;break}c=l.getSpatialNavigationContainer()}}}if(!c&&l){const t=f(a,u(l,i),o,l);if(Array.isArray(t)&&t.length>0&&(r=a.spatialNavigationSearch(o,{candidates:t,container:l}),r))return e?t:r}if(t(l,o))return r=a,r}return{isContainer:E,isScrollContainer:C,isVisibleInScroller:S,findCandidates:e.bind(null,!0),findNextTarget:e.bind(null,!1),getDistanceFromTarget:(t,e,n)=>(E(t)||\"BODY\"===t.nodeName)&&\"INPUT\"!==t.nodeName&&u(t).includes(e)?H(G(t),G(e),n):K(G(t),G(e),n)}}()),window.__spatialNavigation__.keyMode=e,Object.seal(window.__spatialNavigation__)}function Y(){return{enableExperimentalAPIs:z,get keyMode(){return this._keymode?this._keymode:\"ARROW\"},set keyMode(t){this._keymode=[\"SHIFTARROW\",\"ARROW\",\"NONE\"].includes(t)?t:\"ARROW\"},setStartingPoint:function(t,e){n=t&&e?{x:t,y:e}:null}}}window.__getSpatNavState=()=>({mapOfBoundRect:e,startingPoint:n,savedSearchOrigin:o,searchOriginRect:i}),window.navigate=r,window.Element.prototype.spatialNavigationSearch=s,window.Element.prototype.focusableAreas=w,window.Element.prototype.getSpatialNavigationContainer=p,window.CSS&&CSS.registerProperty&&(\"\"===window.getComputedStyle(document.documentElement).getPropertyValue(\"--spatial-navigation-contain\")&&CSS.registerProperty({name:\"--spatial-navigation-contain\",syntax:\"auto | contain\",inherits:!1,initialValue:\"auto\"}),\"\"===window.getComputedStyle(document.documentElement).getPropertyValue(\"--spatial-navigation-action\")&&CSS.registerProperty({name:\"--spatial-navigation-action\",syntax:\"auto | focus | scroll\",inherits:!1,initialValue:\"auto\"}),\"\"===window.getComputedStyle(document.documentElement).getPropertyValue(\"--spatial-navigation-function\")&&CSS.registerProperty({name:\"--spatial-navigation-function\",syntax:\"normal | grid\",inherits:!1,initialValue:\"normal\"})),z(!0),window.addEventListener(\"load\",(()=>{a()}))}();document.addEventListener(\"keyup\",(t=>{13===t.keyCode&&(t.preventDefault(),document.activeElement&&document.activeElement.click())}));var r=n(\"NbAz\"),l=n(\"20a2\"),c=n.n(l),u=n(\"//ZD\"),d=function(t){var e,n,o={goto_catalog:u.a.INDEX,goto_mohito:u.a.MOHITO,goto_tropical:u.a.TROPICAL,goto_orangelemonade:u.a.ORANGE_LEMONADE,goto_mintmilk:u.a.MINT_MILK,goto_iceberg:u.a.ICEBERG,goto_chokomilk:u.a.CHOKOMILK,goto_slad:u.a.SLAD,goto_champ:u.a.CHAMP,goto_ale:u.a.ALE,goto_klement:u.a.KLEMENT,goto_prostuda:u.a.PROSTUDA,goto_gogol:u.a.GOGOL}[null===t||void 0===t||null===(e=t.action)||void 0===e?void 0:e.type];o&&(null===(n=c.a.router)||void 0===n||n.push(o))},s=function(){Object(o.useEffect)((function(){(function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(){return{}};return Object(r.createAssistant)({getState:t})})().on(\"data\",d)}),[])},f=n(\"jT3O\"),m=n(\"Gv25\"),g=n(\"UloT\"),p=n(\"YFqc\"),h=n.n(p),w=n(\"vOnD\"),b=n(\"eK0j\"),y=n(\"YAxo\"),v=i.a.createElement;function x(){var t=Object(f.a)([\"\\n    padding-left: \",\"px;\\n\"]);return x=function(){return t},t}function E(){var t=Object(f.a)([\"\\n    margin-top: 20px;\\n\"]);return E=function(){return t},t}function O(){var t=Object(f.a)([\"\\n    width: \",\";\\n    display: \",\";\\n\"]);return O=function(){return t},t}function C(){var t=Object(f.a)([\"\\n    color: rgba(255, 255, 255, 0.56);\\n    margin-top: 8px;\\n    margin-bottom: 2px;\\n    width: \",\";\\n    display: \",\";\\n\"]);return C=function(){return t},t}function N(){var t=Object(f.a)([\"\\n    margin-bottom: \",\"px;\\n\\n    height: \",\"px;\\n\"]);return N=function(){return t},t}var P=Object(w.default)(m.Card)(N(),\"mobile\"===Object(a.detectDevice)()?8:32,{sberPortal:247,sberBox:336,mobile:165}[Object(a.detectDevice)()]),T=(Object(w.default)(m.Body1)(C(),Object(a.isSberPortal)()?\"100px\":\"100%\",Object(a.isSberPortal)()?\"inline-block\":\"block\"),Object(w.default)(m.Body3)(O(),Object(a.isSberPortal)()?\"calc(100% - 100px)\":\"100%\",Object(a.isSberPortal)()?\"inline-block\":\"block\"),w.default.div(E()),Object(w.default)(m.Col)(x(),{sberPortal:12,sberBox:52,mobile:0}[Object(a.detectDevice)()]),function(t){var e=t.children;return v(m.Col,{sizeS:4,sizeM:3,sizeL:4,sizeXL:6},e)}),M=function(){var t,e=Object(o.useRef)(),n=Object(o.useRef)();return Object(o.useEffect)((function(){var t;n.current=(t=function(){return e.current},Object(r.createAssistant)({getState:t})),n.current.on(\"data\",(function(t){t.action}))}),[]),v(i.a.Fragment,null,v(y.a,{label:\"\\u0411\\u0435\\u0437\\u0430\\u043b\\u043a\\u043e\\u0433\\u043e\\u043b\\u044c\\u043d\\u044b\\u0435 \\u043a\\u043e\\u043a\\u0442\\u0435\\u0439\\u043b\\u0438\",onBack:null===(t=window.AssistantHost)||void 0===t?void 0:t.close}),v(m.Container,null,v(\"div\",{style:{marginLeft:\"auto\",marginRight:\"auto\"}},v(g.Row,null,v(m.Col,{sizeS:4,sizeM:4,sizeL:8,sizeXL:8},v(g.Row,null,v(T,null,v(h.a,{href:u.a.MOHITO},v(P,{outlined:!0,scaleOnFocus:!0,onChange:function(){var t;return null===(t=n.current)||void 0===t?void 0:t.sendData({action:{type:\"MOHITO\"}})}},v(m.CardBody,null,v(b.a,{src:(Object(a.detectDevice)(),\"/mohito.jpg\")}),v(m.CardContent,{cover:!0},v(m.TextBox,null,v(m.TextBoxBigTitle,null,\"\\u041c\\u043e\\u0445\\u0438\\u0442\\u043e\"))))))),v(T,null,v(h.a,{href:u.a.TROPICAL},v(P,{outlined:!0,scaleOnFocus:!0},v(m.CardBody,null,v(b.a,{src:(Object(a.detectDevice)(),\"/tropical.jpeg\")}),v(m.CardContent,{cover:!0},v(m.TextBox,null,v(m.TextBoxBigTitle,null,\"\\u0422\\u0440\\u043e\\u043f\\u0438\\u0447\\u0435\\u0441\\u043a\\u0438\\u0439\"))))))),v(T,null,v(h.a,{href:u.a.ORANGE_LEMONADE},v(P,{outlined:!0,scaleOnFocus:!0},v(m.CardBody,null,v(b.a,{src:(Object(a.detectDevice)(),\"/orange_lemonade.jpeg\")}),v(m.CardContent,{cover:!0},v(m.TextBox,null,v(m.TextBoxBigTitle,null,\"\\u0410\\u043f\\u0435\\u043b\\u044c\\u0441\\u0438\\u043d\\u043e\\u0432\\u044b\\u0439 \\u043b\\u0438\\u043c\\u043e\\u043d\\u0430\\u0434\"))))))),v(T,null,v(h.a,{href:u.a.MINT_MILK},v(P,{outlined:!0,scaleOnFocus:!0},v(m.CardBody,null,v(b.a,{src:(Object(a.detectDevice)(),\"/myatnoe_moloko_1.jpeg\")}),v(m.CardContent,{cover:!0},v(m.TextBox,null,v(m.TextBoxBigTitle,null,\"\\u041c\\u044f\\u0442\\u043d\\u043e\\u0435 \\u043c\\u043e\\u043b\\u043e\\u043a\\u043e\")))))))),v(g.Row,null,v(T,null,v(h.a,{href:u.a.ICEBERG},v(P,{outlined:!0,scaleOnFocus:!0},v(m.CardBody,null,v(b.a,{src:(Object(a.detectDevice)(),\"/iceverg.jpeg\")}),v(m.CardContent,{cover:!0},v(m.TextBox,null,v(m.TextBoxBigTitle,null,\"\\u0410\\u0439\\u0441\\u0431\\u0435\\u0440\\u0433 \\u0432 \\u043e\\u043a\\u0435\\u0430\\u043d\\u0435\"))))))),v(T,null,v(h.a,{href:u.a.CHOKOMILK},v(P,{outlined:!0,scaleOnFocus:!0},v(m.CardBody,null,v(b.a,{src:(Object(a.detectDevice)(),\"/chokomilk.jpeg\")}),v(m.CardContent,{cover:!0},v(m.TextBox,null,v(m.TextBoxBigTitle,null,\"\\u041c\\u043e\\u043b\\u043e\\u0447\\u043d\\u043e-\\u0448\\u043e\\u043a\\u043e\\u043b\\u0430\\u0434\\u043d\\u044b\\u0439 \\u043a\\u043e\\u043a\\u0442\\u0435\\u0439\\u043b\\u044c\"))))))),v(T,null,v(h.a,{href:u.a.SLAD},v(P,{outlined:!0,scaleOnFocus:!0},v(m.CardBody,null,v(b.a,{src:(Object(a.detectDevice)(),\"/slad.png\")}),v(m.CardContent,{cover:!0},v(m.TextBox,null,v(m.TextBoxBigTitle,null,\"\\u0421\\u043b\\u0430\\u0434\\u043a\\u043e\\u0435\\u0436\\u043a\\u0430\"))))))),v(T,null,v(h.a,{href:u.a.CHAMP},v(P,{outlined:!0,scaleOnFocus:!0},v(m.CardBody,null,v(b.a,{src:(Object(a.detectDevice)(),\"/champ.jpeg\")}),v(m.CardContent,{cover:!0},v(m.TextBox,null,v(m.TextBoxBigTitle,null,\"\\u0424\\u0430\\u043b\\u044c\\u0448\\u0438\\u0432\\u043e\\u0435 \\u0448\\u0430\\u043c\\u043f\\u0430\\u043d\\u0441\\u043a\\u043e\\u0435\")))))))),v(g.Row,null,v(T,null,v(h.a,{href:u.a.ALE},v(P,{outlined:!0,scaleOnFocus:!0},v(m.CardBody,null,v(b.a,{src:(Object(a.detectDevice)(),\"/ale.jpeg\")}),v(m.CardContent,{cover:!0},v(m.TextBox,null,v(m.TextBoxBigTitle,null,\"\\u0418\\u043c\\u0431\\u0438\\u0440\\u043d\\u044b\\u0439 \\u044d\\u043b\\u044c\"))))))),v(T,null,v(h.a,{href:u.a.KLEMENT},v(P,{outlined:!0,scaleOnFocus:!0},v(m.CardBody,null,v(b.a,{src:(Object(a.detectDevice)(),\"/klement.jpeg\")}),v(m.CardContent,{cover:!0},v(m.TextBox,null,v(m.TextBoxBigTitle,null,\"\\u0421\\u0435\\u043d\\u0442-\\u041a\\u043b\\u0435\\u043c\\u0435\\u043d\\u0442\"))))))),v(T,null,v(h.a,{href:u.a.PROSTUDA},v(P,{outlined:!0,scaleOnFocus:!0},v(m.CardBody,null,v(b.a,{src:(Object(a.detectDevice)(),\"/prostuda.jpeg\")}),v(m.CardContent,{cover:!0},v(m.TextBox,null,v(m.TextBoxBigTitle,null,\"\\u0423\\u0434\\u0430\\u0440 \\u043f\\u043e \\u043f\\u0440\\u043e\\u0441\\u0442\\u0443\\u0434\\u0435\"))))))),v(T,null,v(h.a,{href:u.a.GOGOL},v(P,{outlined:!0,scaleOnFocus:!0},v(m.CardBody,null,v(b.a,{src:(Object(a.detectDevice)(),\"/gogol.jpeg\")}),v(m.CardContent,{cover:!0},v(m.TextBox,null,v(m.TextBoxBigTitle,null,\"\\u0413\\u043e\\u0433\\u043e\\u043b\\u044c-\\u043c\\u043e\\u0433\\u043e\\u043b\\u044c\")))))))))))))},S=n(\"soUV\"),_=i.a.createElement,B=function(){return s(),_(S.b,{noPadding:Object(a.isSberPortal)()},_(M,null))};e.default=B},YFqc:function(t,e,n){t.exports=n(\"cTJO\")},cTJO:function(t,e,n){\"use strict\";var o=n(\"zoAU\"),i=n(\"7KCV\");e.__esModule=!0,e.default=void 0;var a=i(n(\"cDcd\")),r=n(\"elyg\"),l=n(\"nOHt\"),c=n(\"vNVm\"),u={};function d(t,e,n,o){if(t&&(0,r.isLocalURL)(e)){t.prefetch(e,n,o).catch((function(t){0}));var i=o&&\"undefined\"!==typeof o.locale?o.locale:t&&t.locale;u[e+\"%\"+n+(i?\"%\"+i:\"\")]=!0}}var s=function(t){var e=!1!==t.prefetch,n=(0,l.useRouter)(),i=n&&n.pathname||\"/\",s=a.default.useMemo((function(){var e=(0,r.resolveHref)(i,t.href,!0),n=o(e,2),a=n[0],l=n[1];return{href:a,as:t.as?(0,r.resolveHref)(i,t.as):l||a}}),[i,t.href,t.as]),f=s.href,m=s.as,g=t.children,p=t.replace,h=t.shallow,w=t.scroll,b=t.locale;\"string\"===typeof g&&(g=a.default.createElement(\"a\",null,g));var y=a.Children.only(g),v=y&&\"object\"===typeof y&&y.ref,x=(0,c.useIntersection)({rootMargin:\"200px\"}),E=o(x,2),O=E[0],C=E[1],N=a.default.useCallback((function(t){O(t),v&&(\"function\"===typeof v?v(t):\"object\"===typeof v&&(v.current=t))}),[v,O]);(0,a.useEffect)((function(){var t=C&&e&&(0,r.isLocalURL)(f),o=\"undefined\"!==typeof b?b:n&&n.locale,i=u[f+\"%\"+m+(o?\"%\"+o:\"\")];t&&!i&&d(n,f,m,{locale:o})}),[m,f,C,b,e,n]);var P={ref:N,onClick:function(t){y.props&&\"function\"===typeof y.props.onClick&&y.props.onClick(t),t.defaultPrevented||function(t,e,n,o,i,a,l,c){(\"A\"!==t.currentTarget.nodeName||!function(t){var e=t.currentTarget.target;return e&&\"_self\"!==e||t.metaKey||t.ctrlKey||t.shiftKey||t.altKey||t.nativeEvent&&2===t.nativeEvent.which}(t)&&(0,r.isLocalURL)(n))&&(t.preventDefault(),null==l&&(l=o.indexOf(\"#\")<0),e[i?\"replace\":\"push\"](n,o,{shallow:a,locale:c,scroll:l}))}(t,n,f,m,p,h,w,b)},onMouseEnter:function(t){(0,r.isLocalURL)(f)&&(y.props&&\"function\"===typeof y.props.onMouseEnter&&y.props.onMouseEnter(t),d(n,f,m,{priority:!0}))}};if(t.passHref||\"a\"===y.type&&!(\"href\"in y.props)){var T=\"undefined\"!==typeof b?b:n&&n.locale,M=n&&n.isLocaleDomain&&(0,r.getDomainLocale)(m,T,n&&n.locales,n&&n.domainLocales);P.href=M||(0,r.addBasePath)((0,r.addLocale)(m,T,n&&n.defaultLocale))}return a.default.cloneElement(y,P)};e.default=s},eK0j:function(t,e,n){\"use strict\";var o=n(\"HALo\"),i=n(\"jT3O\"),a=n(\"cDcd\"),r=n.n(a),l=n(\"vOnD\"),c=r.a.createElement;function u(){var t=Object(i.a)([\"\\n    background: url(\",\") no-repeat center center;\\n    background-size: cover;\\n    width: \",\";\\n    height: \",\";\\n\"]);return u=function(){return t},t}var d=l.default.div(u(),(function(t){return t.src}),(function(t){var e=t.width;return e?\"\".concat(e,\"px\"):\"100%\"}),(function(t){var e=t.height;return e?\"\".concat(e,\"px\"):\"100%\"}));e.a=function(t){var e=Object(o.a)({},t);return c(d,e)}},vNVm:function(t,e,n){\"use strict\";var o=n(\"zoAU\");e.__esModule=!0,e.useIntersection=function(t){var e=t.rootMargin,n=t.disabled||!r,c=(0,i.useRef)(),u=(0,i.useState)(!1),d=o(u,2),s=d[0],f=d[1],m=(0,i.useCallback)((function(t){c.current&&(c.current(),c.current=void 0),n||s||t&&t.tagName&&(c.current=function(t,e,n){var o=function(t){var e=t.rootMargin||\"\",n=l.get(e);if(n)return n;var o=new Map,i=new IntersectionObserver((function(t){t.forEach((function(t){var e=o.get(t.target),n=t.isIntersecting||t.intersectionRatio>0;e&&n&&e(n)}))}),t);return l.set(e,n={id:e,observer:i,elements:o}),n}(n),i=o.id,a=o.observer,r=o.elements;return r.set(t,e),a.observe(t),function(){r.delete(t),a.unobserve(t),0===r.size&&(a.disconnect(),l.delete(i))}}(t,(function(t){return t&&f(t)}),{rootMargin:e}))}),[n,e,s]);return(0,i.useEffect)((function(){if(!r&&!s){var t=(0,a.requestIdleCallback)((function(){return f(!0)}));return function(){return(0,a.cancelIdleCallback)(t)}}}),[s]),[m,s]};var i=n(\"cDcd\"),a=n(\"0G5g\"),r=\"undefined\"!==typeof IntersectionObserver;var l=new Map}}]);","map":{"version":3,"sources":["static/chunks/26.4c2d32ab460b3fcdab64.js"],"names":["window","push","//ZD","module","__webpack_exports__","__webpack_require__","Route","d","KdaB","r","Root_Root","external_React_","external_React_default","n","deviceDetection","ARROW_KEY_CODE","37","38","39","40","mapOfBoundRect","startingPoint","savedSearchOrigin","element","rect","searchOriginRect","spatialNavigationHandler","addEventListener","e","currentKeyMode","parent","__spatialNavigation__","keyMode","eventTarget","document","activeElement","dir","keyCode","shiftKey","ctrlKey","metaKey","altKey","defaultPrevented","focusNavigableArrowKey","left","up","right","down","nodeName","SPINNABLE_INPUT_TYPES","TEXT_INPUT_TYPES","startPosition","selectionStart","endPosition","selectionEnd","undefined","includes","getAttribute","value","length","handlingEditableElement","preventDefault","Map","navigate","x","clientX","y","clientY","target","getBoundingClientRect","searchOrigin","body","querySelector","elementStyle","getComputedStyle","invisibleStyle","disabled","getPropertyValue","documentElement","height","width","top","bottom","isVisibleInScroller","scroller","getScrollContainer","findSearchOrigin","elementFromPosition","elementFromPoint","isFocusable","isContainer","getSpatialNavigationContainer","container","contentDocument","bestInsideCandidate","spatialNavigationSearch","candidates","getSpatialNavigationCandidates","mode","focusingController","parentContainer","parentElement","location","navigateChain","bestCandidate","createSpatNavEvents","focus","preventScroll","scrollingController","isScrollable","isScrollBoundary","moveScroll","isHTMLScrollBoundary","ownerDocument","option","childElementCount","getElementsByTagName","children","elem","isDelegableContainer","concat","filter","isVisible","getFilteredSpatialNavigationCandidates","targetElement","filteredCandidates","args","this","bestTarget","internalCandidates","externalCandidates","insideOverlappedCandidates","focusableAreas","overlappedCandidates","forEach","isEntirelyVisible","getOverlappedCandidates","defaultContainer","defaultCandidates","contains","candidate","fullyOverlapped","overlappedByParent","map","elm","flat","currentElm","getClosestElement","getDistanceFromPoint","getInnerDistance","selectBestCandidateFromEdge","selectBestCandidate","innerTarget","descendantsBest","splice","indexOf","originalContainer","eventTargetRect","candidateRect","candidateBody","isOutside","isInside","spatialNavigationFunction","currentTargetRect","distanceFunction","alignedCandidates","isAligned","getAbsoluteDistance","getDistance","frameElement","minDistance","Number","POSITIVE_INFINITY","minDistanceElements","i","distance","getEuclideanDistance","scrollContainer","isScrollContainer","focusables","Array","prototype","call","eventType","containerElement","currentElement","direction","triggeredEvent","CustomEvent","bubbles","cancelable","detail","causedTarget","dispatchEvent","readCssVar","varName","trim","currentOption","nextContainer","offset","scrollLeft","scrollTop","isCSSSpatNavContain","overflowX","overflowY","isOverflow","scrollWidth","clientWidth","scrollHeight","clientHeight","result","winScrollY","winScrollX","Math","abs","elementRect","nearestScroller","scrollerRect","DOMRect","innerWidth","innerHeight","tabIndex","tagName","isAtagWithoutHref","isActuallyDisabled","inert","isExpresslyInert","isVisibleStyleProperty","style","opacity","isBeingRendered","offsetX","parseInt","offsetWidth","offsetY","offsetHeight","isNaN","hitTestPoint","middle","leftTop","rightBottom","point","elemFromPoint","hitTest","containerRect","thisVisibility","childRect","rightEdgeCheck","leftEdgeCheck","topEdgeCheck","bottomEdgeCheck","rect1","rect2","isRightSide","isBelow","points","getEntryAndExitPoints","P1","entryPoint","exitPoint","P2","sqrt","pow","baseEdge","orthogonalBias","alignBias","A","B","C","intersectionRect","intersection_rect","area","new_location","max","new_max_point","min","getIntersectionRect","D","get","boundingClientRect","toFixed","set","enableExperimentalAPIs","getInitialAPIs","Object","assign","canScroll","findTarget","findCandidate","bestNextTarget","isArray","findCandidates","bind","findNextTarget","getDistanceFromTarget","candidateElement","getExperimentalAPI","seal","_keymode","setStartingPoint","__getSpatNavState","Element","CSS","registerProperty","name","syntax","inherits","initialValue","event","click","dist","router","router_default","routes","useAssistant_processMessage","message","_message$action","_Router$router","route","goto_catalog","INDEX","goto_mohito","MOHITO","goto_tropical","TROPICAL","goto_orangelemonade","ORANGE_LEMONADE","goto_mintmilk","MINT_MILK","goto_iceberg","ICEBERG","goto_chokomilk","CHOKOMILK","goto_slad","SLAD","goto_champ","CHAMP","goto_ale","ALE","goto_klement","KLEMENT","goto_prostuda","PROSTUDA","goto_gogol","GOGOL","action","type","a","useAssistant_useAssistant","getState","arguments","useAssistant_initialize","on","taggedTemplateLiteral","es","Grid","next_link","link_default","styled_components_browser_esm","Img","MyHeader","__jsx","createElement","_templateObject5","data","_templateObject4","_templateObject3","_templateObject2","_templateObject","StyledCard","sberPortal","sberBox","mobile","Catalog_Half","div","_ref","sizeS","sizeM","sizeL","sizeXL","components_Catalog","_window$AssistantHost","assistantStateRef","assistantRef","current","_ref2","Fragment","label","onBack","AssistantHost","close","marginLeft","marginRight","href","outlined","scaleOnFocus","onChange","_assistantRef$current","sendData","src","cover","Layout","Root_jsx","noPadding","YFqc","exports","cTJO","_slicedToArray","_interopRequireWildcard","__esModule","default","_react","_router","_router2","_useIntersection","prefetched","prefetch","as","options","isLocalURL","catch","err","curLocale","locale","_default","props","p","useRouter","pathname","_react$default$useMem","useMemo","resolveHref","resolvedHref","resolvedAs","replace","shallow","scroll","child","Children","only","childRef","ref","_ref3","useIntersection","rootMargin","_ref4","setIntersectionRef","setRef","useCallback","el","useEffect","shouldPrefetch","isPrefetched","childProps","onClick","currentTarget","nativeEvent","which","isModifiedEvent","linkClicked","onMouseEnter","priority","passHref","localeDomain","isLocaleDomain","getDomainLocale","locales","domainLocales","addBasePath","addLocale","defaultLocale","cloneElement","eK0j","C_Users_Professional_Documents_summer_drink_main_node_modules_next_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__","C_Users_Professional_Documents_summer_drink_main_node_modules_next_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_1__","react__WEBPACK_IMPORTED_MODULE_2__","react__WEBPACK_IMPORTED_MODULE_2___default","styled_components__WEBPACK_IMPORTED_MODULE_3__","StyledImage","vNVm","isDisabled","hasIntersectionObserver","unobserve","useRef","useState","visible","setVisible","callback","_createObserver","id","instance","observers","elements","observer","IntersectionObserver","entries","entry","isIntersecting","intersectionRatio","createObserver","observe","delete","size","disconnect","idleCallback","_requestIdleCallback","requestIdleCallback","cancelIdleCallback"],"mappings":"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"},"name":"static/chunks/26.4c2d32ab460b3fcdab64.js","input":"(window[\"webpackJsonp_N_E\"] = window[\"webpackJsonp_N_E\"] || []).push([[26],{\n\n/***/ \"//ZD\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Route; });\nvar Route;\n\n(function (Route) {\n  Route[\"INDEX\"] = \"/\";\n  Route[\"MOHITO\"] = \"/mohito\";\n  Route[\"TROPICAL\"] = \"/tropical\";\n  Route[\"ORANGE_LEMONADE\"] = \"/orange_lemonade\";\n  Route[\"MINT_MILK\"] = \"/mint_milk\";\n  Route[\"ICEBERG\"] = \"/iceberg\";\n  Route[\"CHOKOMILK\"] = \"/chokomilk\";\n  Route[\"SLAD\"] = \"/slad\";\n  Route[\"CHAMP\"] = \"/champ\";\n  Route[\"ALE\"] = \"/ale\";\n  Route[\"KLEMENT\"] = \"/klement\";\n  Route[\"PROSTUDA\"] = \"/prostuda\";\n  Route[\"GOGOL\"] = \"/gogol\";\n})(Route || (Route = {}));\n\n/***/ }),\n\n/***/ \"KdaB\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"Root\", function() { return /* binding */ Root_Root; });\n\n// EXTERNAL MODULE: external \"React\"\nvar external_React_ = __webpack_require__(\"cDcd\");\nvar external_React_default = /*#__PURE__*/__webpack_require__.n(external_React_);\n\n// EXTERNAL MODULE: ./node_modules/@sberdevices/plasma-ui/utils/deviceDetection.js\nvar deviceDetection = __webpack_require__(\"weFX\");\n\n// CONCATENATED MODULE: ./node_modules/@sberdevices/spatial-navigation/polyfill/spatial-navigation-polyfill.js\n/* eslint-disable */\n\n/* Spatial Navigation Polyfill\n *\n * It follows W3C official specification\n * https://drafts.csswg.org/css-nav-1/\n *\n * Copyright (c) 2018-2019 LG Electronics Inc.\n * https://github.com/WICG/spatial-navigation/polyfill\n *\n * Licensed under the MIT license (MIT)\n */\n\n(function () {\n    // The polyfill must not be executed, if it's already enabled via browser engine or browser extensions.\n    if ('navigate' in window) {\n        return;\n    }\n\n    const ARROW_KEY_CODE = { 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n    const TAB_KEY_CODE = 9;\n    let mapOfBoundRect = null;\n    let startingPoint = null; // Saves spatial navigation starting point\n    let savedSearchOrigin = { element: null, rect: null }; // Saves previous search origin\n    let searchOriginRect = null; // Rect of current search origin\n\n    window.__getSpatNavState = () => {\n        return {\n            mapOfBoundRect,\n            startingPoint,\n            savedSearchOrigin,\n            searchOriginRect,\n        };\n    };\n\n    /**\n     * Initiate the spatial navigation features of the polyfill.\n     * @function initiateSpatialNavigation\n     */\n    function initiateSpatialNavigation() {\n        /*\n         * Bind the standards APIs to be exposed to the window object for authors\n         */\n        window.navigate = navigate;\n        window.Element.prototype.spatialNavigationSearch = spatialNavigationSearch;\n        window.Element.prototype.focusableAreas = focusableAreas;\n        window.Element.prototype.getSpatialNavigationContainer = getSpatialNavigationContainer;\n\n        /*\n         * CSS.registerProperty() from the Properties and Values API\n         * Reference: https://drafts.css-houdini.org/css-properties-values-api/#the-registerproperty-function\n         */\n        if (window.CSS && CSS.registerProperty) {\n            if (\n                window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-contain') ===\n                ''\n            ) {\n                CSS.registerProperty({\n                    name: '--spatial-navigation-contain',\n                    syntax: 'auto | contain',\n                    inherits: false,\n                    initialValue: 'auto',\n                });\n            }\n\n            if (\n                window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-action') === ''\n            ) {\n                CSS.registerProperty({\n                    name: '--spatial-navigation-action',\n                    syntax: 'auto | focus | scroll',\n                    inherits: false,\n                    initialValue: 'auto',\n                });\n            }\n\n            if (\n                window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-function') ===\n                ''\n            ) {\n                CSS.registerProperty({\n                    name: '--spatial-navigation-function',\n                    syntax: 'normal | grid',\n                    inherits: false,\n                    initialValue: 'normal',\n                });\n            }\n        }\n    }\n\n    /**\n     * Add event handlers for the spatial navigation behavior.\n     * This function defines which input methods trigger the spatial navigation behavior.\n     * @function spatialNavigationHandler\n     */\n    function spatialNavigationHandler() {\n        /*\n         * keydown EventListener :\n         * If arrow key pressed, get the next focusing element and send it to focusing controller\n         */\n        window.addEventListener('keydown', (e) => {\n            const currentKeyMode =\n                (parent && parent.__spatialNavigation__ && parent.__spatialNavigation__.keyMode) ||\n                (window.__spatialNavigation__ && window.__spatialNavigation__.keyMode);\n            const eventTarget = document.activeElement;\n            const dir = ARROW_KEY_CODE[e.keyCode];\n\n            if (e.keyCode === TAB_KEY_CODE) {\n                startingPoint = null;\n            }\n\n            if (\n                !currentKeyMode ||\n                currentKeyMode === 'NONE' ||\n                (currentKeyMode === 'SHIFTARROW' && !e.shiftKey) ||\n                (currentKeyMode === 'ARROW' && e.shiftKey) ||\n                e.ctrlKey ||\n                e.metaKey ||\n                e.altKey\n            )\n                return;\n\n            if (!e.defaultPrevented) {\n                let focusNavigableArrowKey = {\n                    left: true,\n                    up: true,\n                    right: true,\n                    down: true,\n                };\n\n                // Edge case (text input, area) : Don't move focus, just navigate cursor in text area\n                if (eventTarget.nodeName === 'INPUT' || eventTarget.nodeName === 'TEXTAREA') {\n                    focusNavigableArrowKey = handlingEditableElement(e);\n                }\n\n                if (focusNavigableArrowKey[dir]) {\n                    e.preventDefault();\n                    mapOfBoundRect = new Map();\n\n                    navigate(dir);\n\n                    mapOfBoundRect = null;\n                    startingPoint = null;\n                }\n            }\n        });\n\n        /*\n         * mouseup EventListener :\n         * If the mouse click a point in the page, the point will be the starting point.\n         * NOTE: Let UA set the spatial navigation starting point based on click\n         */\n        document.addEventListener('mouseup', (e) => {\n            startingPoint = { x: e.clientX, y: e.clientY };\n        });\n\n        /*\n         * focusin EventListener :\n         * When the element get the focus, save it and its DOMRect for resetting the search origin\n         * if it disappears.\n         */\n        window.addEventListener('focusin', (e) => {\n            if (e.target !== window) {\n                savedSearchOrigin.element = e.target;\n                savedSearchOrigin.rect = e.target.getBoundingClientRect();\n            }\n        });\n    }\n\n    /**\n     * Enable the author to trigger spatial navigation programmatically, as if the user had done so manually.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#dom-window-navigate}\n     * @function navigate\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     */\n    function navigate(dir) {\n        // spatial navigation steps\n\n        // 1\n        const searchOrigin = findSearchOrigin();\n        let eventTarget = searchOrigin;\n        let elementFromPosition = null;\n\n        // 2 Optional step, UA defined starting point\n        if (startingPoint) {\n            // if there is a starting point, set eventTarget as the element from position for getting the spatnav container\n            elementFromPosition = document.elementFromPoint(startingPoint.x, startingPoint.y);\n\n            // Use starting point if the starting point isn't inside the focusable element (but not container)\n            // * Starting point is meaningfull when:\n            // 1) starting point is inside the spatnav container\n            // 2) starting point is inside the non-focusable element\n            if (elementFromPosition === null) {\n                elementFromPosition = document.body;\n            }\n            if (isFocusable(elementFromPosition) && !isContainer(elementFromPosition)) {\n                startingPoint = null;\n            } else if (isContainer(elementFromPosition)) {\n                eventTarget = elementFromPosition;\n            } else {\n                eventTarget = elementFromPosition.getSpatialNavigationContainer();\n            }\n        }\n\n        // 4\n        if (eventTarget === window || eventTarget === document || eventTarget === document.documentElement) {\n            eventTarget = document.body || document.documentElement;\n        }\n\n        // 5\n        // At this point, spatialNavigationSearch can be applied.\n        // If startingPoint is either a scroll container or the document,\n        // find the best candidate within startingPoint\n        let container = null;\n        if ((isContainer(eventTarget) || eventTarget.nodeName === 'BODY') && !(eventTarget.nodeName === 'INPUT')) {\n            if (eventTarget.nodeName === 'IFRAME') {\n                eventTarget = eventTarget.contentDocument.documentElement;\n            }\n\n            container = container === window ? document.body : eventTarget;\n            let bestInsideCandidate = null;\n\n            // 5-2\n            if (\n                document.activeElement === searchOrigin ||\n                (document.activeElement === document.body && searchOrigin === document.documentElement)\n            ) {\n                if (getCSSSpatNavAction(eventTarget) === 'scroll') {\n                    if (scrollingController(eventTarget, dir)) return;\n                } else if (getCSSSpatNavAction(eventTarget) === 'focus') {\n                    bestInsideCandidate = eventTarget.spatialNavigationSearch(dir, {\n                        container: eventTarget,\n                        candidates: getSpatialNavigationCandidates(eventTarget, {\n                            mode: 'all',\n                        }),\n                    });\n                    if (focusingController(bestInsideCandidate, dir)) return;\n                } else if (getCSSSpatNavAction(eventTarget) === 'auto') {\n                    bestInsideCandidate = eventTarget.spatialNavigationSearch(dir, {\n                        container: eventTarget,\n                    });\n                    if (focusingController(bestInsideCandidate, dir) || scrollingController(eventTarget, dir)) return;\n                }\n            } else {\n                // when the previous search origin became offscreen\n                container = container.getSpatialNavigationContainer();\n            }\n        }\n\n        // 6\n        // Let container be the nearest ancestor of eventTarget\n        container = eventTarget.getSpatialNavigationContainer();\n        let parentContainer = container.parentElement ? container.getSpatialNavigationContainer() : null;\n\n        // When the container is the viewport of a browsing context\n        if (!parentContainer && window.location !== window.parent.location) {\n            parentContainer = window.parent.document.documentElement;\n        }\n\n        if (getCSSSpatNavAction(container) === 'scroll') {\n            if (scrollingController(container, dir)) return;\n        } else if (getCSSSpatNavAction(container) === 'focus') {\n            navigateChain(eventTarget, container, parentContainer, dir, 'all');\n        } else if (getCSSSpatNavAction(container) === 'auto') {\n            navigateChain(eventTarget, container, parentContainer, dir, 'visible');\n        }\n    }\n\n    /**\n     * Move the focus to the best candidate or do nothing.\n     * @function focusingController\n     * @param bestCandidate {Node} - The best candidate of the spatial navigation\n     * @param dir {SpatialNavigationDirection}- The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function focusingController(bestCandidate, dir) {\n        // 10 & 11\n        // When bestCandidate is found\n        if (bestCandidate) {\n            // When bestCandidate is a focusable element and not a container : move focus\n            /*\n             * [event] navbeforefocus : Fired before spatial or sequential navigation changes the focus.\n             */\n            if (!createSpatNavEvents('beforefocus', bestCandidate, null, dir)) return true;\n\n            const container = bestCandidate.getSpatialNavigationContainer();\n\n            if (container !== window && getCSSSpatNavAction(container) === 'focus') {\n                bestCandidate.focus();\n            } else {\n                bestCandidate.focus({ preventScroll: true });\n            }\n\n            startingPoint = null;\n            return true;\n        }\n\n        // When bestCandidate is not found within the scrollport of a container: Nothing\n        return false;\n    }\n\n    /**\n     * Directionally scroll the scrollable spatial navigation container if it can be manually scrolled more.\n     * @function scrollingController\n     * @param container {Node} - The spatial navigation container which can scroll\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function scrollingController(container, dir) {\n        // If there is any scrollable area among parent elements and it can be manually scrolled, scroll the document\n        if (isScrollable(container, dir) && !isScrollBoundary(container, dir)) {\n            moveScroll(container, dir);\n            return true;\n        }\n\n        // If the spatnav container is document and it can be scrolled, scroll the document\n        if (!container.parentElement && !isHTMLScrollBoundary(container, dir)) {\n            moveScroll(container.ownerDocument.documentElement, dir);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Find the candidates within a spatial navigation container include delegable container.\n     * This function does not search inside delegable container or focusable container.\n     * In other words, this return candidates set is not included focusable elements inside delegable container or focusable container.\n     *\n     * @function getSpatialNavigationCandidates\n     * @param container {Node} - The spatial navigation container\n     * @param option {FocusableAreasOptions} - 'mode' attribute takes 'visible' or 'all' for searching the boundary of focusable elements.\n     *                                          Default value is 'visible'.\n     * @returns {sequence<Node>} candidate elements within the container\n     */\n    function getSpatialNavigationCandidates(container, option = { mode: 'visible' }) {\n        let candidates = [];\n\n        if (container.childElementCount > 0) {\n            if (!container.parentElement) {\n                container = container.getElementsByTagName('body')[0] || document.body;\n            }\n            const children = container.children;\n            for (const elem of children) {\n                if (isDelegableContainer(elem)) {\n                    candidates.push(elem);\n                } else if (isFocusable(elem)) {\n                    candidates.push(elem);\n\n                    if (!isContainer(elem) && elem.childElementCount) {\n                        candidates = candidates.concat(getSpatialNavigationCandidates(elem, { mode: 'all' }));\n                    }\n                } else if (elem.childElementCount) {\n                    candidates = candidates.concat(getSpatialNavigationCandidates(elem, { mode: 'all' }));\n                }\n            }\n        }\n\n        return option.mode === 'all' ? candidates : candidates.filter(isVisible);\n    }\n\n    /**\n     * Find the candidates among focusable elements within a spatial navigation container from the search origin (currently focused element)\n     * depending on the directional information.\n     * @function getFilteredSpatialNavigationCandidates\n     * @param element {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation without the directional information\n     * @param container {Node} - The spatial navigation container\n     * @returns {Node} The candidates for spatial navigation considering the directional information\n     */\n    function getFilteredSpatialNavigationCandidates(element, dir, candidates, container) {\n        const targetElement = element;\n        // Removed below line due to a bug. (iframe body rect is sometime weird.)\n        // const targetElement = (element.nodeName === 'IFRAME') ? element.contentDocument.body : element;\n        // If the container is unknown, get the closest container from the element\n        container = container || targetElement.getSpatialNavigationContainer();\n\n        // If the candidates is unknown, find candidates\n        // 5-1\n        candidates = !candidates || candidates.length <= 0 ? getSpatialNavigationCandidates(container) : candidates;\n        return filteredCandidates(targetElement, candidates, dir, container);\n    }\n\n    /**\n     * Find the best candidate among the candidates within the container from the search origin (currently focused element)\n     * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-spatialnavigationsearch}\n     * @function spatialNavigationSearch\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param container {Node} - The spatial navigation container\n     * @returns {Node} The best candidate which will gain the focus\n     */\n    function spatialNavigationSearch(dir, args) {\n        const targetElement = this;\n        let internalCandidates = [];\n        let externalCandidates = [];\n        let insideOverlappedCandidates = getOverlappedCandidates(targetElement);\n        let bestTarget;\n\n        // Set default parameter value\n        if (!args) args = {};\n\n        const defaultContainer = targetElement.getSpatialNavigationContainer();\n        let defaultCandidates = getSpatialNavigationCandidates(defaultContainer);\n        const container = args.container || defaultContainer;\n        if (args.container && defaultContainer.contains(args.container)) {\n            defaultCandidates = defaultCandidates.concat(getSpatialNavigationCandidates(container));\n        }\n        const candidates =\n            args.candidates && args.candidates.length > 0\n                ? args.candidates.filter((candidate) => container.contains(candidate))\n                : defaultCandidates.filter((candidate) => container.contains(candidate) && container !== candidate);\n\n        // Find the best candidate\n        // 5\n        // If startingPoint is either a scroll container or the document,\n        // find the best candidate within startingPoint\n        if (candidates && candidates.length > 0) {\n            // Divide internal or external candidates\n            candidates.forEach((candidate) => {\n                if (candidate !== targetElement) {\n                    (targetElement.contains(candidate) && targetElement !== candidate\n                        ? internalCandidates\n                        : externalCandidates\n                    ).push(candidate);\n                }\n            });\n\n            // include overlapped element to the internalCandidates\n            let fullyOverlapped = insideOverlappedCandidates.filter(\n                (candidate) => !internalCandidates.includes(candidate),\n            );\n            let overlappedContainer = candidates.filter(\n                (candidate) => isContainer(candidate) && isEntirelyVisible(targetElement, candidate),\n            );\n            let overlappedByParent = overlappedContainer\n                .map((elm) => elm.focusableAreas())\n                .flat()\n                .filter((candidate) => candidate !== targetElement);\n\n            internalCandidates = internalCandidates\n                .concat(fullyOverlapped)\n                .filter((candidate) => container.contains(candidate));\n            externalCandidates = externalCandidates\n                .concat(overlappedByParent)\n                .filter((candidate) => container.contains(candidate));\n\n            // Filter external Candidates\n            if (externalCandidates.length > 0) {\n                externalCandidates = getFilteredSpatialNavigationCandidates(\n                    targetElement,\n                    dir,\n                    externalCandidates,\n                    container,\n                );\n            }\n\n            // If there isn't search origin element but search orgin rect exist  (search origin isn't in the layout case)\n            if (searchOriginRect) {\n                bestTarget = selectBestCandidate(\n                    targetElement,\n                    getFilteredSpatialNavigationCandidates(targetElement, dir, internalCandidates, container),\n                    dir,\n                );\n            }\n\n            if (internalCandidates && internalCandidates.length > 0 && !(targetElement.nodeName === 'INPUT')) {\n                bestTarget = selectBestCandidateFromEdge(targetElement, internalCandidates, dir);\n            }\n\n            bestTarget = bestTarget || selectBestCandidate(targetElement, externalCandidates, dir);\n\n            if (bestTarget && isDelegableContainer(bestTarget)) {\n                // if best target is delegable container, then find descendants candidate inside delegable container.\n                const innerTarget = getSpatialNavigationCandidates(bestTarget, {\n                    mode: 'all',\n                });\n                const descendantsBest =\n                    innerTarget.length > 0\n                        ? targetElement.spatialNavigationSearch(dir, {\n                              candidates: innerTarget,\n                              container: bestTarget,\n                          })\n                        : null;\n                if (descendantsBest) {\n                    bestTarget = descendantsBest;\n                } else if (!isFocusable(bestTarget)) {\n                    // if there is no target inside bestTarget and delegable container is not focusable,\n                    // then try to find another best target without curren best target.\n                    candidates.splice(candidates.indexOf(bestTarget), 1);\n                    bestTarget = candidates.length\n                        ? targetElement.spatialNavigationSearch(dir, {\n                              candidates: candidates,\n                              container: container,\n                          })\n                        : null;\n                }\n            }\n            return bestTarget;\n        }\n\n        return null;\n    }\n\n    /**\n     * Get the filtered candidate among candidates.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate}\n     * @function filteredCandidates\n     * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param container {Node} - The spatial navigation container\n     * @returns {sequence<Node>} The filtered candidates which are not the search origin and not in the given spatial navigation direction from the search origin\n     */\n    // TODO: Need to fix filtering the candidates with more clean code\n    function filteredCandidates(currentElm, candidates, dir, container) {\n        const originalContainer = currentElm.getSpatialNavigationContainer();\n        let eventTargetRect;\n\n        // If D(dir) is null, let candidates be the same as visibles\n        if (dir === undefined) return candidates;\n\n        // Offscreen handling when originalContainer is not <HTML>\n        if (originalContainer.parentElement && container !== originalContainer && !isVisible(currentElm)) {\n            eventTargetRect = getBoundingClientRect(originalContainer);\n        } else {\n            eventTargetRect = searchOriginRect || getBoundingClientRect(currentElm);\n        }\n\n        /*\n         * Else, let candidates be the subset of the elements in visibles\n         * whose principal boxs geometric center is within the closed half plane\n         * whose boundary goes through the geometric center of starting point and is perpendicular to D.\n         */\n        if ((isContainer(currentElm) || currentElm.nodeName === 'BODY') && !(currentElm.nodeName === 'INPUT')) {\n            return candidates.filter((candidate) => {\n                const candidateRect = getBoundingClientRect(candidate);\n                return (\n                    container.contains(candidate) &&\n                    ((currentElm.contains(candidate) &&\n                        isInside(eventTargetRect, candidateRect) &&\n                        candidate !== currentElm) ||\n                        isOutside(candidateRect, eventTargetRect, dir))\n                );\n            });\n        } else {\n            return candidates.filter((candidate) => {\n                const candidateRect = getBoundingClientRect(candidate);\n                const candidateBody = candidate.nodeName === 'IFRAME' ? candidate.contentDocument.body : null;\n                return (\n                    container.contains(candidate) &&\n                    candidate !== currentElm &&\n                    candidateBody !== currentElm &&\n                    isOutside(candidateRect, eventTargetRect, dir) &&\n                    !isInside(eventTargetRect, candidateRect)\n                );\n            });\n        }\n    }\n\n    /**\n     * Select the best candidate among given candidates.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate}\n     * @function selectBestCandidate\n     * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Node} The best candidate which will gain the focus\n     */\n    function selectBestCandidate(currentElm, candidates, dir) {\n        const container = currentElm.getSpatialNavigationContainer();\n        const spatialNavigationFunction = getComputedStyle(container).getPropertyValue('--spatial-navigation-function');\n        const currentTargetRect = searchOriginRect || getBoundingClientRect(currentElm);\n        let distanceFunction;\n        let alignedCandidates;\n\n        switch (spatialNavigationFunction) {\n            case 'grid':\n                alignedCandidates = candidates.filter((elm) =>\n                    isAligned(currentTargetRect, getBoundingClientRect(elm), dir),\n                );\n                if (alignedCandidates.length > 0) {\n                    candidates = alignedCandidates;\n                }\n                distanceFunction = getAbsoluteDistance;\n                break;\n            default:\n                distanceFunction = getDistance;\n                break;\n        }\n        return getClosestElement(currentElm, candidates, dir, distanceFunction);\n    }\n\n    /**\n     * Select the best candidate among candidates by finding the closet candidate from the edge of the currently focused element (search origin).\n     * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate (Step 5)}\n     * @function selectBestCandidateFromEdge\n     * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Node} The best candidate which will gain the focus\n     */\n    function selectBestCandidateFromEdge(currentElm, candidates, dir) {\n        if (startingPoint) return getClosestElement(currentElm, candidates, dir, getDistanceFromPoint);\n        else return getClosestElement(currentElm, candidates, dir, getInnerDistance);\n    }\n\n    /**\n     * Select the closest candidate from the currently focused element (search origin) among candidates by using the distance function.\n     * @function getClosestElement\n     * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param distanceFunction {function} - The distance function which measures the distance from the search origin to each candidate\n     * @returns {Node} The candidate which is the closest one from the search origin\n     */\n    function getClosestElement(currentElm, candidates, dir, distanceFunction) {\n        let eventTargetRect = null;\n        if (\n            window.location !== window.parent.location &&\n            (currentElm.nodeName === 'BODY' || currentElm.nodeName === 'HTML')\n        ) {\n            // If the eventTarget is iframe, then get rect of it based on its containing document\n            // Set the iframe's position as (0,0) because the rects of elements inside the iframe don't know the real iframe's position.\n            eventTargetRect = window.frameElement.getBoundingClientRect();\n            eventTargetRect.x = 0;\n            eventTargetRect.y = 0;\n        } else {\n            eventTargetRect = searchOriginRect || currentElm.getBoundingClientRect();\n        }\n\n        let minDistance = Number.POSITIVE_INFINITY;\n        let minDistanceElements = [];\n\n        if (candidates) {\n            for (let i = 0; i < candidates.length; i++) {\n                const distance = distanceFunction(eventTargetRect, getBoundingClientRect(candidates[i]), dir);\n\n                // If the same distance, the candidate will be selected in the DOM order\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    minDistanceElements = [candidates[i]];\n                } else if (distance === minDistance) {\n                    minDistanceElements.push(candidates[i]);\n                }\n            }\n        }\n        if (minDistanceElements.length === 0) return null;\n\n        return minDistanceElements.length > 1 && distanceFunction === getAbsoluteDistance\n            ? getClosestElement(currentElm, minDistanceElements, dir, getEuclideanDistance)\n            : minDistanceElements[0];\n    }\n\n    /**\n     * Get container of an element.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-getspatialnavigationcontainer}\n     * @module Element\n     * @function getSpatialNavigationContainer\n     * @returns {Node} The spatial navigation container\n     */\n    function getSpatialNavigationContainer() {\n        let container = this;\n\n        do {\n            if (!container.parentElement) {\n                if (window.location !== window.parent.location) {\n                    container = window.parent.document.documentElement;\n                } else {\n                    container = window.document.documentElement;\n                }\n                break;\n            } else {\n                container = container.parentElement;\n            }\n\n        } while (!isContainer(container));\n        return container;\n    }\n\n    /**\n     * Get nearest scroll container of an element.\n     * @function getScrollContainer\n     * @param Element\n     * @returns {Node} The spatial navigation container\n     */\n    function getScrollContainer(element) {\n        let scrollContainer = element;\n\n        do {\n            if (!scrollContainer.parentElement) {\n                if (window.location !== window.parent.location) {\n                    scrollContainer = window.parent.document.documentElement;\n                } else {\n                    scrollContainer = window.document.documentElement;\n                }\n                break;\n            } else {\n                scrollContainer = scrollContainer.parentElement;\n            }\n        } while (!isScrollContainer(scrollContainer) || !isVisible(scrollContainer));\n\n        if (scrollContainer === document || scrollContainer === document.documentElement) {\n            scrollContainer = window;\n        }\n\n        return scrollContainer;\n    }\n\n    /**\n     * Find focusable elements within the spatial navigation container.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-focusableareas}\n     * @function focusableAreas\n     * @param option {FocusableAreasOptions} - 'mode' attribute takes 'visible' or 'all' for searching the boundary of focusable elements.\n     *                                          Default value is 'visible'.\n     * @returns {sequence<Node>} All focusable elements or only visible focusable elements within the container\n     */\n    function focusableAreas(option = { mode: 'visible' }) {\n        const container = this.parentElement ? this : document.body;\n        const focusables = Array.prototype.filter.call(container.getElementsByTagName('*'), isFocusable);\n        return option.mode === 'all' ? focusables : focusables.filter(isVisible);\n    }\n\n    /**\n     * Create the NavigationEvent: navbeforefocus, navnotarget\n     * @see {@link https://drafts.csswg.org/css-nav-1/#events-navigationevent}\n     * @function createSpatNavEvents\n     * @param option {string} - Type of the navigation event (beforefocus, notarget)\n     * @param element {Node} - The target element of the event\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     */\n    function createSpatNavEvents(eventType, containerElement, currentElement, direction) {\n        if (['beforefocus', 'notarget'].includes(eventType)) {\n            const data = {\n                causedTarget: currentElement,\n                dir: direction,\n            };\n            const triggeredEvent = new CustomEvent('nav' + eventType, {\n                bubbles: true,\n                cancelable: true,\n                detail: data,\n            });\n            return containerElement.dispatchEvent(triggeredEvent);\n        }\n    }\n\n    /**\n     * Get the value of the CSS custom property of the element\n     * @function readCssVar\n     * @param element {Node}\n     * @param varName {string} - The name of the css custom property without '--'\n     * @returns {string} The value of the css custom property\n     */\n    function readCssVar(element, varName) {\n        return getComputedStyle(element).getPropertyValue(`--${varName}`).trim();\n    }\n\n    /**\n     * Decide whether or not the 'contain' value is given to 'spatial-navigation-contain' css property of an element\n     * @function isCSSSpatNavContain\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isCSSSpatNavContain(element) {\n        return readCssVar(element, 'spatial-navigation-contain') === 'contain';\n    }\n\n    /**\n     * Return the value of 'spatial-navigation-action' css property of an element\n     * @function getCSSSpatNavAction\n     * @param element {Node} - would be the spatial navigation container\n     * @returns {string} auto | focus | scroll\n     */\n    function getCSSSpatNavAction(element) {\n        return 'focus';\n        //   return readCssVar(element, 'spatial-navigation-action') || 'auto';\n    }\n\n    /**\n     * Only move the focus with spatial navigation. Manually scrolling isn't available.\n     * @function navigateChain\n     * @param eventTarget {Node} - currently focused element\n     * @param container {SpatialNavigationContainer} - container\n     * @param parentContainer {SpatialNavigationContainer} - parent container\n     * @param option - visible || all\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     */\n    function navigateChain(eventTarget, container, parentContainer, dir, option) {\n        let currentOption = {\n            candidates: getSpatialNavigationCandidates(container, { mode: option }),\n            container,\n        };\n\n        while (parentContainer) {\n            if (focusingController(eventTarget.spatialNavigationSearch(dir, currentOption), dir)) {\n                return;\n            } else {\n                if (option === 'visible' && scrollingController(container, dir)) return;\n                else {\n                    if (!createSpatNavEvents('notarget', container, eventTarget, dir)) return;\n\n                    // find the container\n                    if (container === document || container === document.documentElement) {\n                        if (window.location !== window.parent.location) {\n                            // The page is in an iframe. eventTarget needs to be reset because the position of the element in the iframe\n                            eventTarget = window.frameElement;\n                            container = eventTarget.ownerDocument.documentElement;\n                        }\n                    } else {\n                        container = parentContainer;\n                    }\n                    currentOption = {\n                        candidates: getSpatialNavigationCandidates(container, {\n                            mode: option,\n                        }),\n                        container,\n                    };\n                    let nextContainer = container.getSpatialNavigationContainer();\n\n                    if (nextContainer !== container) {\n                        parentContainer = nextContainer;\n                    } else {\n                        parentContainer = null;\n                    }\n                }\n            }\n        }\n\n        currentOption = {\n            candidates: getSpatialNavigationCandidates(container, { mode: option }),\n            container,\n        };\n\n        // Behavior after 'navnotarget' - Getting out from the current spatnav container\n        if (\n            !parentContainer &&\n            container &&\n            focusingController(eventTarget.spatialNavigationSearch(dir, currentOption), dir)\n        )\n            return;\n\n        if (!createSpatNavEvents('notarget', currentOption.container, eventTarget, dir)) return;\n\n        if (getCSSSpatNavAction(container) === 'auto' && option === 'visible') {\n            if (scrollingController(container, dir)) return;\n        }\n    }\n\n    /**\n     * Find search origin\n     * @see {@link https://drafts.csswg.org/css-nav-1/#nav}\n     * @function findSearchOrigin\n     * @returns {Node} The search origin for the spatial navigation\n     */\n    function findSearchOrigin() {\n        let searchOrigin = document.activeElement;\n\n        if (!searchOrigin || (searchOrigin === document.body && !document.querySelector(':focus'))) {\n            // When the previous search origin lost its focus by blur: (1) disable attribute (2) visibility: hidden\n            if (savedSearchOrigin.element && searchOrigin !== savedSearchOrigin.element) {\n                const elementStyle = window.getComputedStyle(savedSearchOrigin.element, null);\n                const invisibleStyle = ['hidden', 'collapse'];\n\n                if (\n                    savedSearchOrigin.element.disabled ||\n                    invisibleStyle.includes(elementStyle.getPropertyValue('visibility'))\n                ) {\n                    searchOrigin = savedSearchOrigin.element;\n                    return searchOrigin;\n                }\n            }\n            searchOrigin = document.documentElement;\n        }\n        // When the previous search origin lost its focus by blur: (1) display:none () element size turned into zero\n        if (\n            savedSearchOrigin.element &&\n            (getBoundingClientRect(savedSearchOrigin.element).height === 0 ||\n                getBoundingClientRect(savedSearchOrigin.element).width === 0)\n        ) {\n            (startingPoint = (savedSearchOrigin.left + savedSearchOrigin.right) / 2),\n                (savedSearchOrigin.top + savedSearchOrigin.bottom) / 2;\n            // searchOriginRect = savedSearchOrigin.rect;\n        }\n\n        if (!isVisibleInScroller(searchOrigin)) {\n            const scroller = getScrollContainer(searchOrigin);\n            if (scroller && (scroller === window || getCSSSpatNavAction(scroller) === 'auto')) return scroller;\n        }\n        return searchOrigin;\n    }\n\n    /**\n     * Move the scroll of an element depending on the given spatial navigation directrion\n     * (Assume that User Agent defined distance is '40px')\n     * @see {@link https://drafts.csswg.org/css-nav-1/#directionally-scroll-an-element}\n     * @function moveScroll\n     * @param element {Node} - The scrollable element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param offset {Number} - The explicit amount of offset for scrolling. Default value is 0.\n     */\n    function moveScroll(element, dir, offset = 0) {\n        if (element) {\n            switch (dir) {\n                case 'left':\n                    element.scrollLeft -= 40 + offset;\n                    break;\n                case 'right':\n                    element.scrollLeft += 40 + offset;\n                    break;\n                case 'up':\n                    element.scrollTop -= 40 + offset;\n                    break;\n                case 'down':\n                    element.scrollTop += 40 + offset;\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Decide whether an element is container or not.\n     * @function isContainer\n     * @param element {Node} element\n     * @returns {boolean}\n     */\n    function isContainer(element) {\n        return (\n            !element.parentElement ||\n            element.nodeName === 'IFRAME' ||\n            isScrollContainer(element) ||\n            isCSSSpatNavContain(element)\n        );\n    }\n\n    /**\n     * Decide whether an element is delegable container or not.\n     * NOTE: THIS IS NON-NORMATIVE API.\n     * @function isDelegableContainer\n     * @param element {Node} element\n     * @returns {boolean}\n     */\n    function isDelegableContainer(element) {\n        return readCssVar(element, 'spatial-navigation-contain') === 'delegable';\n    }\n\n    /**\n     * Decide whether an element is a scrollable container or not.\n     * @see {@link https://drafts.csswg.org/css-overflow-3/#scroll-container}\n     * @function isScrollContainer\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isScrollContainer(element) {\n        const elementStyle = window.getComputedStyle(element, null);\n        const overflowX = elementStyle.getPropertyValue('overflow-x');\n        const overflowY = elementStyle.getPropertyValue('overflow-y');\n\n        return (overflowX !== 'visible' && overflowX !== 'clip' && isOverflow(element, 'left')) ||\n            (overflowY !== 'visible' && overflowY !== 'clip' && isOverflow(element, 'down'))\n            ? true\n            : false;\n    }\n\n    /**\n     * Decide whether this element is scrollable or not.\n     * NOTE: If the value of 'overflow' is given to either 'visible', 'clip', or 'hidden', the element isn't scrollable.\n     *       If the value is 'hidden', the element can be only programmically scrollable. (https://drafts.csswg.org/css-overflow-3/#valdef-overflow-hidden)\n     * @function isScrollable\n     * @param element {Node}\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isScrollable(element, dir) {\n        // element, dir\n        if (element && typeof element === 'object') {\n            if (dir && typeof dir === 'string') {\n                // parameter: dir, element\n                if (isOverflow(element, dir)) {\n                    // style property\n                    const elementStyle = window.getComputedStyle(element, null);\n                    const overflowX = elementStyle.getPropertyValue('overflow-x');\n                    const overflowY = elementStyle.getPropertyValue('overflow-y');\n\n                    switch (dir) {\n                        case 'left':\n                        /* falls through */\n                        case 'right':\n                            return overflowX !== 'visible' && overflowX !== 'clip' && overflowX !== 'hidden';\n                        case 'up':\n                        /* falls through */\n                        case 'down':\n                            return overflowY !== 'visible' && overflowY !== 'clip' && overflowY !== 'hidden';\n                    }\n                }\n                return false;\n            } else {\n                // parameter: element\n                return (\n                    element.nodeName === 'HTML' ||\n                    element.nodeName === 'BODY' ||\n                    (isScrollContainer(element) && isOverflow(element))\n                );\n            }\n        }\n    }\n\n    /**\n     * Decide whether an element is overflow or not.\n     * @function isOverflow\n     * @param element {Node}\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isOverflow(element, dir) {\n        if (element && typeof element === 'object') {\n            if (dir && typeof dir === 'string') {\n                // parameter: element, dir\n                switch (dir) {\n                    case 'left':\n                    /* falls through */\n                    case 'right':\n                        return element.scrollWidth > element.clientWidth;\n                    case 'up':\n                    /* falls through */\n                    case 'down':\n                        return element.scrollHeight > element.clientHeight;\n                }\n            } else {\n                // parameter: element\n                return element.scrollWidth > element.clientWidth || element.scrollHeight > element.clientHeight;\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Decide whether the scrollbar of the browsing context reaches to the end or not.\n     * @function isHTMLScrollBoundary\n     * @param element {Node} - The top browsing context\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isHTMLScrollBoundary(element, dir) {\n        let result = false;\n        switch (dir) {\n            case 'left':\n                result = element.scrollLeft === 0;\n                break;\n            case 'right':\n                result = element.scrollWidth - element.scrollLeft - element.clientWidth === 0;\n                break;\n            case 'up':\n                result = element.scrollTop === 0;\n                break;\n            case 'down':\n                result = element.scrollHeight - element.scrollTop - element.clientHeight === 0;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Decide whether the scrollbar of an element reaches to the end or not.\n     * @function isScrollBoundary\n     * @param element {Node}\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isScrollBoundary(element, dir) {\n        if (isScrollable(element, dir)) {\n            const winScrollY = element.scrollTop;\n            const winScrollX = element.scrollLeft;\n\n            const height = element.scrollHeight - element.clientHeight;\n            const width = element.scrollWidth - element.clientWidth;\n\n            switch (dir) {\n                case 'left':\n                    return winScrollX === 0;\n                case 'right':\n                    return Math.abs(winScrollX - width) <= 1;\n                case 'up':\n                    return winScrollY === 0;\n                case 'down':\n                    return Math.abs(winScrollY - height) <= 1;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Decide whether an element is inside the scorller viewport or not\n     *\n     * @function isVisibleInScroller\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isVisibleInScroller(element) {\n        const elementRect = element.getBoundingClientRect();\n        let nearestScroller = getScrollContainer(element);\n\n        let scrollerRect = null;\n        if (nearestScroller !== window) {\n            scrollerRect = getBoundingClientRect(nearestScroller);\n        } else {\n            scrollerRect = new DOMRect(0, 0, window.innerWidth, window.innerHeight);\n        }\n\n        if (isInside(scrollerRect, elementRect, 'left') && isInside(scrollerRect, elementRect, 'down')) return true;\n        else return false;\n    }\n\n    /**\n     * Decide whether an element is focusable for spatial navigation.\n     * 1. If element is the browsing context (document, iframe), then it's focusable,\n     * 2. If the element is scrollable container (regardless of scrollable axis), then it's focusable,\n     * 3. The value of tabIndex >= 0, then it's focusable,\n     * 4. If the element is disabled, it isn't focusable,\n     * 5. If the element is expressly inert, it isn't focusable,\n     * 6. Whether the element is being rendered or not.\n     *\n     * @function isFocusable\n     * @param element {Node}\n     * @returns {boolean}\n     *\n     * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#focusable-area}\n     */\n    function isFocusable(element) {\n        if (\n            element.tabIndex < 0 ||\n            isAtagWithoutHref(element) ||\n            isActuallyDisabled(element) ||\n            isExpresslyInert(element) ||\n            !isBeingRendered(element)\n        )\n            return false;\n        else if (!element.parentElement || (isScrollable(element) && isOverflow(element)) || element.tabIndex >= 0)\n            return true;\n    }\n\n    /**\n     * Decide whether an element is a tag without href attribute or not.\n     *\n     * @function isAtagWithoutHref\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isAtagWithoutHref(element) {\n        return (\n            element.tagName === 'A' &&\n            element.getAttribute('href') === null &&\n            element.getAttribute('tabIndex') === null\n        );\n    }\n\n    /**\n     * Decide whether an element is actually disabled or not.\n     *\n     * @function isActuallyDisabled\n     * @param element {Node}\n     * @returns {boolean}\n     *\n     * @see {@link https://html.spec.whatwg.org/multipage/semantics-other.html#concept-element-disabled}\n     */\n    function isActuallyDisabled(element) {\n        if (['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTGROUP', 'OPTION', 'FIELDSET'].includes(element.tagName))\n            return element.disabled;\n        else return false;\n    }\n\n    /**\n     * Decide whether the element is expressly inert or not.\n     * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#expressly-inert}\n     * @function isExpresslyInert\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isExpresslyInert(element) {\n        return element.inert && !element.ownerDocument.documentElement.inert;\n    }\n\n    /**\n     * Decide whether the element is being rendered or not.\n     * 1. If an element has the style as \"visibility: hidden | collapse\" or \"display: none\", it is not being rendered.\n     * 2. If an element has the style as \"opacity: 0\", it is not being rendered.(that is, invisible).\n     * 3. If width and height of an element are explicitly set to 0, it is not being rendered.\n     * 4. If a parent element is hidden, an element itself is not being rendered.\n     * (CSS visibility property and display property are inherited.)\n     * @see {@link https://html.spec.whatwg.org/multipage/rendering.html#being-rendered}\n     * @function isBeingRendered\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isBeingRendered(element) {\n        if (!isVisibleStyleProperty(element.parentElement)) return false;\n        if (\n            !isVisibleStyleProperty(element) ||\n            element.style.opacity === '0' ||\n            window.getComputedStyle(element).height === '0px' ||\n            window.getComputedStyle(element).width === '0px'\n        )\n            return false;\n        return true;\n    }\n\n    /**\n     * Decide whether this element is partially or completely visible to user agent.\n     * @function isVisible\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isVisible(element) {\n        return !element.parentElement || (isVisibleStyleProperty(element) && hitTest(element));\n    }\n\n    /**\n     * Decide whether this element is completely visible in this viewport for the arrow direction.\n     * @function isEntirelyVisible\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isEntirelyVisible(element, container) {\n        const rect = getBoundingClientRect(element);\n        const containerElm = container || element.getSpatialNavigationContainer();\n        const containerRect = getBoundingClientRect(containerElm);\n\n        // FIXME: when element is bigger than container?\n        const entirelyVisible = !(\n            rect.left < containerRect.left ||\n            rect.right > containerRect.right ||\n            rect.top < containerRect.top ||\n            rect.bottom > containerRect.bottom\n        );\n\n        return entirelyVisible;\n    }\n\n    /**\n     * Decide the style property of this element is specified whether it's visible or not.\n     * @function isVisibleStyleProperty\n     * @param element {CSSStyleDeclaration}\n     * @returns {boolean}\n     */\n    function isVisibleStyleProperty(element) {\n        const elementStyle = window.getComputedStyle(element, null);\n        const thisVisibility = elementStyle.getPropertyValue('visibility');\n        const thisDisplay = elementStyle.getPropertyValue('display');\n        const invisibleStyle = ['hidden', 'collapse'];\n\n        return thisDisplay !== 'none' && !invisibleStyle.includes(thisVisibility);\n    }\n\n    /**\n     * Decide whether this element is entirely or partially visible within the viewport.\n     * @function hitTest\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function hitTest(element) {\n        const elementRect = getBoundingClientRect(element);\n        if (\n            element.nodeName !== 'IFRAME' &&\n            (elementRect.top < 0 ||\n                elementRect.left < 0 ||\n                elementRect.top > element.ownerDocument.documentElement.clientHeight ||\n                elementRect.left > element.ownerDocument.documentElement.clientWidth)\n        )\n            return false;\n\n        let offsetX = parseInt(element.offsetWidth) / 10;\n        let offsetY = parseInt(element.offsetHeight) / 10;\n\n        offsetX = isNaN(offsetX) ? 1 : offsetX;\n        offsetY = isNaN(offsetY) ? 1 : offsetY;\n\n        const hitTestPoint = {\n            // For performance, just using the three point(middle, leftTop, rightBottom) of the element for hit testing\n            middle: [(elementRect.left + elementRect.right) / 2, (elementRect.top + elementRect.bottom) / 2],\n            leftTop: [elementRect.left + offsetX, elementRect.top + offsetY],\n            rightBottom: [elementRect.right - offsetX, elementRect.bottom - offsetY],\n        };\n\n        for (const point in hitTestPoint) {\n            const elemFromPoint = element.ownerDocument.elementFromPoint(...hitTestPoint[point]);\n            if (element === elemFromPoint || element.contains(elemFromPoint)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Decide whether a child element is entirely or partially Included within container visually.\n     * @function isInside\n     * @param containerRect {DOMRect}\n     * @param childRect {DOMRect}\n     * @returns {boolean}\n     */\n    function isInside(containerRect, childRect) {\n        const rightEdgeCheck = containerRect.left < childRect.right && containerRect.right >= childRect.right;\n        const leftEdgeCheck = containerRect.left <= childRect.left && containerRect.right > childRect.left;\n        const topEdgeCheck = containerRect.top <= childRect.top && containerRect.bottom > childRect.top;\n        const bottomEdgeCheck = containerRect.top < childRect.bottom && containerRect.bottom >= childRect.bottom;\n        return (rightEdgeCheck || leftEdgeCheck) && (topEdgeCheck || bottomEdgeCheck);\n    }\n\n    /**\n     * Decide whether this element is entirely or partially visible within the viewport.\n     * Note: rect1 is outside of rect2 for the dir\n     * @function isOutside\n     * @param rect1 {DOMRect}\n     * @param rect2 {DOMRect}\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isOutside(rect1, rect2, dir) {\n        switch (dir) {\n            case 'left':\n                return isRightSide(rect2, rect1);\n            case 'right':\n                return isRightSide(rect1, rect2);\n            case 'up':\n                return isBelow(rect2, rect1);\n            case 'down':\n                return isBelow(rect1, rect2);\n            default:\n                return false;\n        }\n    }\n\n    /* rect1 is right of rect2 */\n    function isRightSide(rect1, rect2) {\n        return (\n            rect1.left >= rect2.right ||\n            (rect1.left >= rect2.left &&\n                rect1.right > rect2.right &&\n                rect1.bottom > rect2.top &&\n                rect1.top < rect2.bottom)\n        );\n    }\n\n    /* rect1 is below of rect2 */\n    function isBelow(rect1, rect2) {\n        return (\n            rect1.top >= rect2.bottom ||\n            (rect1.top >= rect2.top &&\n                rect1.bottom > rect2.bottom &&\n                rect1.left < rect2.right &&\n                rect1.right > rect2.left)\n        );\n    }\n\n    /* rect1 is completely aligned or partially aligned for the direction */\n    function isAligned(rect1, rect2, dir) {\n        switch (dir) {\n            case 'left':\n            /* falls through */\n            case 'right':\n                return rect1.bottom > rect2.top && rect1.top < rect2.bottom;\n            case 'up':\n            /* falls through */\n            case 'down':\n                return rect1.right > rect2.left && rect1.left < rect2.right;\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * Get distance between the search origin and a candidate element along the direction when candidate element is inside the search origin.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}\n     * @function getDistanceFromPoint\n     * @param point {Point} - The search origin\n     * @param element {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The euclidian distance between the spatial navigation container and an element inside it\n     */\n    function getDistanceFromPoint(point, element, dir) {\n        point = startingPoint;\n        // Get exit point, entry point -> {x: '', y: ''};\n        const points = getEntryAndExitPoints(dir, point, element);\n\n        // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate\n        // that minimize the distance between these two points\n        const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);\n        const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);\n\n        // The result is euclidian distance between P1 and P2.\n        return Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));\n    }\n\n    /**\n     * Get distance between the search origin and a candidate element along the direction when candidate element is inside the search origin.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}\n     * @function getInnerDistance\n     * @param rect1 {DOMRect} - The search origin\n     * @param rect2 {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The euclidean distance between the spatial navigation container and an element inside it\n     */\n    function getInnerDistance(rect1, rect2, dir) {\n        const baseEdgeForEachDirection = {\n            left: 'right',\n            right: 'left',\n            up: 'bottom',\n            down: 'top',\n        };\n        const baseEdge = baseEdgeForEachDirection[dir];\n\n        return Math.abs(rect1[baseEdge] - rect2[baseEdge]);\n    }\n\n    /**\n     * Get the distance between the search origin and a candidate element considering the direction.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#calculating-the-distance}\n     * @function getDistance\n     * @param searchOrigin {DOMRect | Point} - The search origin\n     * @param candidateRect {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The distance scoring between two elements\n     */\n    function getDistance(searchOrigin, candidateRect, dir) {\n        const kOrthogonalWeightForLeftRight = 30;\n        const kOrthogonalWeightForUpDown = 2;\n\n        let orthogonalBias = 0;\n        let alignBias = 0;\n        const alignWeight = 5.0;\n\n        // Get exit point, entry point -> {x: '', y: ''};\n        const points = getEntryAndExitPoints(dir, searchOrigin, candidateRect);\n\n        // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate\n        // that minimize the distance between these two points\n        const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);\n        const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);\n\n        // A: The euclidean distance between P1 and P2.\n        const A = Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));\n        let B, C;\n\n        // B: The absolute distance in the direction which is orthogonal to dir between P1 and P2, or 0 if dir is null.\n        // C: The intersection edges between a candidate and the starting point.\n\n        // D: The square root of the area of intersection between the border boxes of candidate and starting point\n        const intersectionRect = getIntersectionRect(searchOrigin, candidateRect);\n        const D = intersectionRect.area;\n\n        switch (dir) {\n            case 'left':\n            /* falls through */\n            case 'right':\n                // If two elements are aligned, add align bias\n                // else, add orthogonal bias\n                if (isAligned(searchOrigin, candidateRect, dir))\n                    alignBias = Math.min(intersectionRect.height / searchOrigin.height, 1);\n                else orthogonalBias = searchOrigin.height / 2;\n\n                B = (P2 + orthogonalBias) * kOrthogonalWeightForLeftRight;\n                C = alignWeight * alignBias;\n                break;\n\n            case 'up':\n            /* falls through */\n            case 'down':\n                // If two elements are aligned, add align bias\n                // else, add orthogonal bias\n                if (isAligned(searchOrigin, candidateRect, dir))\n                    alignBias = Math.min(intersectionRect.width / searchOrigin.width, 1);\n                else orthogonalBias = searchOrigin.width / 2;\n\n                B = (P1 + orthogonalBias) * kOrthogonalWeightForUpDown;\n                C = alignWeight * alignBias;\n                break;\n\n            default:\n                B = 0;\n                C = 0;\n                break;\n        }\n\n        return A + B - C - D;\n    }\n\n    /**\n     * Get the euclidean distance between the search origin and a candidate element considering the direction.\n     * @function getEuclideanDistance\n     * @param rect1 {DOMRect} - The search origin\n     * @param rect2 {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The distance scoring between two elements\n     */\n    function getEuclideanDistance(rect1, rect2, dir) {\n        // Get exit point, entry point\n        const points = getEntryAndExitPoints(dir, rect1, rect2);\n\n        // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate\n        // that minimize the distance between these two points\n        const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);\n        const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);\n\n        // Return the euclidean distance between P1 and P2.\n        return Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));\n    }\n\n    /**\n     * Get the absolute distance between the search origin and a candidate element considering the direction.\n     * @function getAbsoluteDistance\n     * @param rect1 {DOMRect} - The search origin\n     * @param rect2 {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The distance scoring between two elements\n     */\n    function getAbsoluteDistance(rect1, rect2, dir) {\n        // Get exit point, entry point\n        const points = getEntryAndExitPoints(dir, rect1, rect2);\n\n        // Return the absolute distance in the dir direction between P1 and P.\n        return dir === 'left' || dir === 'right'\n            ? Math.abs(points.entryPoint.x - points.exitPoint.x)\n            : Math.abs(points.entryPoint.y - points.exitPoint.y);\n    }\n\n    /**\n     * Get entry point and exit point of two elements considering the direction.\n     * @function getEntryAndExitPoints\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD). Default value for dir is 'down'.\n     * @param searchOrigin {DOMRect | Point} - The search origin which contains the exit point\n     * @param candidateRect {DOMRect} - One of candidates which contains the entry point\n     * @returns {Points} The exit point from the search origin and the entry point from a candidate\n     */\n    function getEntryAndExitPoints(dir = 'down', searchOrigin, candidateRect) {\n        /**\n         * User type definition for Point\n         * @typeof {Object} Points\n         * @property {Point} Points.entryPoint\n         * @property {Point} Points.exitPoint\n         */\n        const points = { entryPoint: { x: 0, y: 0 }, exitPoint: { x: 0, y: 0 } };\n\n        if (startingPoint) {\n            points.exitPoint = searchOrigin;\n\n            switch (dir) {\n                case 'left':\n                    points.entryPoint.x = candidateRect.right;\n                    break;\n                case 'up':\n                    points.entryPoint.y = candidateRect.bottom;\n                    break;\n                case 'right':\n                    points.entryPoint.x = candidateRect.left;\n                    break;\n                case 'down':\n                    points.entryPoint.y = candidateRect.top;\n                    break;\n            }\n\n            // Set orthogonal direction\n            switch (dir) {\n                case 'left':\n                case 'right':\n                    if (startingPoint.y <= candidateRect.top) {\n                        points.entryPoint.y = candidateRect.top;\n                    } else if (startingPoint.y < candidateRect.bottom) {\n                        points.entryPoint.y = startingPoint.y;\n                    } else {\n                        points.entryPoint.y = candidateRect.bottom;\n                    }\n                    break;\n\n                case 'up':\n                case 'down':\n                    if (startingPoint.x <= candidateRect.left) {\n                        points.entryPoint.x = candidateRect.left;\n                    } else if (startingPoint.x < candidateRect.right) {\n                        points.entryPoint.x = startingPoint.x;\n                    } else {\n                        points.entryPoint.x = candidateRect.right;\n                    }\n                    break;\n            }\n        } else {\n            // Set direction\n            switch (dir) {\n                case 'left':\n                    points.exitPoint.x = searchOrigin.left;\n                    points.entryPoint.x =\n                        candidateRect.right < searchOrigin.left ? candidateRect.right : searchOrigin.left;\n                    break;\n                case 'up':\n                    points.exitPoint.y = searchOrigin.top;\n                    points.entryPoint.y =\n                        candidateRect.bottom < searchOrigin.top ? candidateRect.bottom : searchOrigin.top;\n                    break;\n                case 'right':\n                    points.exitPoint.x = searchOrigin.right;\n                    points.entryPoint.x =\n                        candidateRect.left > searchOrigin.right ? candidateRect.left : searchOrigin.right;\n                    break;\n                case 'down':\n                    points.exitPoint.y = searchOrigin.bottom;\n                    points.entryPoint.y =\n                        candidateRect.top > searchOrigin.bottom ? candidateRect.top : searchOrigin.bottom;\n                    break;\n            }\n\n            // Set orthogonal direction\n            switch (dir) {\n                case 'left':\n                case 'right':\n                    if (isBelow(searchOrigin, candidateRect)) {\n                        points.exitPoint.y = searchOrigin.top;\n                        points.entryPoint.y =\n                            candidateRect.bottom < searchOrigin.top ? candidateRect.bottom : searchOrigin.top;\n                    } else if (isBelow(candidateRect, searchOrigin)) {\n                        points.exitPoint.y = searchOrigin.bottom;\n                        points.entryPoint.y =\n                            candidateRect.top > searchOrigin.bottom ? candidateRect.top : searchOrigin.bottom;\n                    } else {\n                        points.exitPoint.y = Math.max(searchOrigin.top, candidateRect.top);\n                        points.entryPoint.y = points.exitPoint.y;\n                    }\n                    break;\n\n                case 'up':\n                case 'down':\n                    if (isRightSide(searchOrigin, candidateRect)) {\n                        points.exitPoint.x = searchOrigin.left;\n                        points.entryPoint.x =\n                            candidateRect.right < searchOrigin.left ? candidateRect.right : searchOrigin.left;\n                    } else if (isRightSide(candidateRect, searchOrigin)) {\n                        points.exitPoint.x = searchOrigin.right;\n                        points.entryPoint.x =\n                            candidateRect.left > searchOrigin.right ? candidateRect.left : searchOrigin.right;\n                    } else {\n                        points.exitPoint.x = Math.max(searchOrigin.left, candidateRect.left);\n                        points.entryPoint.x = points.exitPoint.x;\n                    }\n                    break;\n            }\n        }\n\n        return points;\n    }\n\n    /**\n     * Find focusable elements within the container\n     * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}\n     * @function getIntersectionRect\n     * @param rect1 {DOMRect} - The search origin which contains the exit point\n     * @param rect2 {DOMRect} - One of candidates which contains the entry point\n     * @returns {IntersectionArea} The intersection area between two elements.\n     *\n     * @typeof {Object} IntersectionArea\n     * @property {Number} IntersectionArea.width\n     * @property {Number} IntersectionArea.height\n     */\n    function getIntersectionRect(rect1, rect2) {\n        const intersection_rect = { width: 0, height: 0, area: 0 };\n\n        const new_location = [Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)];\n        const new_max_point = [Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom)];\n\n        intersection_rect.width = Math.abs(new_location[0] - new_max_point[0]);\n        intersection_rect.height = Math.abs(new_location[1] - new_max_point[1]);\n\n        if (!(new_location[0] >= new_max_point[0] || new_location[1] >= new_max_point[1])) {\n            // intersecting-cases\n            intersection_rect.area = Math.sqrt(intersection_rect.width * intersection_rect.height);\n        }\n\n        return intersection_rect;\n    }\n\n    /**\n     * Handle the spatial navigation behavior for HTMLInputElement, HTMLTextAreaElement\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input|HTMLInputElement (MDN)}\n     * @function handlingEditableElement\n     * @param e {Event} - keydownEvent\n     * @returns {boolean}\n     */\n    function handlingEditableElement(e) {\n        const SPINNABLE_INPUT_TYPES = ['email', 'date', 'month', 'number', 'time', 'week'],\n            TEXT_INPUT_TYPES = ['password', 'text', 'search', 'tel', 'url', null];\n        const eventTarget = document.activeElement;\n        const startPosition = eventTarget.selectionStart;\n        const endPosition = eventTarget.selectionEnd;\n        const focusNavigableArrowKey = {\n            left: false,\n            up: false,\n            right: false,\n            down: false,\n        };\n\n        const dir = ARROW_KEY_CODE[e.keyCode];\n        if (dir === undefined) {\n            return focusNavigableArrowKey;\n        }\n\n        if (SPINNABLE_INPUT_TYPES.includes(eventTarget.getAttribute('type')) && (dir === 'up' || dir === 'down')) {\n            focusNavigableArrowKey[dir] = true;\n        } else if (TEXT_INPUT_TYPES.includes(eventTarget.getAttribute('type')) || eventTarget.nodeName === 'TEXTAREA') {\n            if (startPosition === endPosition) {\n                // if there isn't any selected text\n                if (startPosition === 0) {\n                    focusNavigableArrowKey.left = true;\n                    focusNavigableArrowKey.up = true;\n                }\n                if (endPosition === eventTarget.value.length) {\n                    focusNavigableArrowKey.right = true;\n                    focusNavigableArrowKey.down = true;\n                }\n            }\n        } else {\n            // HTMLDataListElement, HTMLSelectElement, HTMLOptGroup\n            focusNavigableArrowKey[dir] = true;\n        }\n\n        return focusNavigableArrowKey;\n    }\n\n    /**\n     * Get the DOMRect of an element\n     * @function getBoundingClientRect\n     * @param {Node} element\n     * @returns {DOMRect}\n     */\n    function getBoundingClientRect(element) {\n        // memoization\n        let rect = mapOfBoundRect && mapOfBoundRect.get(element);\n        if (!rect) {\n            const boundingClientRect = element.getBoundingClientRect();\n            rect = {\n                top: Number(boundingClientRect.top.toFixed(2)),\n                right: Number(boundingClientRect.right.toFixed(2)),\n                bottom: Number(boundingClientRect.bottom.toFixed(2)),\n                left: Number(boundingClientRect.left.toFixed(2)),\n                width: Number(boundingClientRect.width.toFixed(2)),\n                height: Number(boundingClientRect.height.toFixed(2)),\n            };\n            mapOfBoundRect && mapOfBoundRect.set(element, rect);\n        }\n        return rect;\n    }\n\n    /**\n     * Get the candidates which is fully inside the target element in visual\n     * @param {Node} targetElement\n     * @returns {sequence<Node>}  overlappedCandidates\n     */\n    function getOverlappedCandidates(targetElement) {\n        const container = targetElement.getSpatialNavigationContainer();\n        const candidates = container.focusableAreas();\n        const overlappedCandidates = [];\n\n        candidates.forEach((element) => {\n            if (targetElement !== element && isEntirelyVisible(element, targetElement)) {\n                overlappedCandidates.push(element);\n            }\n        });\n\n        return overlappedCandidates;\n    }\n\n    /**\n     * Get the list of the experimental APIs\n     * @function getExperimentalAPI\n     */\n    function getExperimentalAPI() {\n        function canScroll(container, dir) {\n            return (\n                (isScrollable(container, dir) && !isScrollBoundary(container, dir)) ||\n                (!container.parentElement && !isHTMLScrollBoundary(container, dir))\n            );\n        }\n\n        function findTarget(findCandidate, element, dir, option) {\n            let eventTarget = element;\n            let bestNextTarget = null;\n\n            // 4\n            if (eventTarget === document || eventTarget === document.documentElement) {\n                eventTarget = document.body || document.documentElement;\n            }\n\n            // 5\n            // At this point, spatialNavigationSearch can be applied.\n            // If startingPoint is either a scroll container or the document,\n            // find the best candidate within startingPoint\n            if ((isContainer(eventTarget) || eventTarget.nodeName === 'BODY') && !(eventTarget.nodeName === 'INPUT')) {\n                if (eventTarget.nodeName === 'IFRAME') eventTarget = eventTarget.contentDocument.body;\n\n                const candidates = getSpatialNavigationCandidates(eventTarget, option);\n\n                // 5-2\n                if (Array.isArray(candidates) && candidates.length > 0) {\n                    return findCandidate\n                        ? getFilteredSpatialNavigationCandidates(eventTarget, dir, candidates)\n                        : eventTarget.spatialNavigationSearch(dir, { candidates });\n                }\n                if (canScroll(eventTarget, dir)) {\n                    return findCandidate ? [] : eventTarget;\n                }\n            }\n\n            // 6\n            // Let container be the nearest ancestor of eventTarget\n            let container = eventTarget.getSpatialNavigationContainer();\n            let parentContainer = container.parentElement ? container.getSpatialNavigationContainer() : null;\n\n            // When the container is the viewport of a browsing context\n            if (!parentContainer && window.location !== window.parent.location) {\n                parentContainer = window.parent.document.documentElement;\n            }\n\n            // 7\n            while (parentContainer) {\n                const candidates = filteredCandidates(\n                    eventTarget,\n                    getSpatialNavigationCandidates(container, option),\n                    dir,\n                    container,\n                );\n\n                if (Array.isArray(candidates) && candidates.length > 0) {\n                    bestNextTarget = eventTarget.spatialNavigationSearch(dir, {\n                        candidates,\n                        container,\n                    });\n                    if (bestNextTarget) {\n                        return findCandidate ? candidates : bestNextTarget;\n                    }\n                }\n\n                // If there isn't any candidate and the best candidate among candidate:\n                // 1) Scroll or 2) Find candidates of the ancestor container\n                // 8 - if\n                else if (canScroll(container, dir)) {\n                    return findCandidate ? [] : eventTarget;\n                } else if (container === document || container === document.documentElement) {\n                    container = window.document.documentElement;\n\n                    // The page is in an iframe\n                    if (window.location !== window.parent.location) {\n                        // eventTarget needs to be reset because the position of the element in the IFRAME\n                        // is unuseful when the focus moves out of the iframe\n                        eventTarget = window.frameElement;\n                        container = window.parent.document.documentElement;\n                        if (container.parentElement) parentContainer = container.getSpatialNavigationContainer();\n                        else {\n                            parentContainer = null;\n                            break;\n                        }\n                    }\n                } else {\n                    // avoiding when spatnav container with tabindex=-1\n                    if (isFocusable(container)) {\n                        eventTarget = container;\n                    }\n\n                    container = parentContainer;\n                    if (container.parentElement) parentContainer = container.getSpatialNavigationContainer();\n                    else {\n                        parentContainer = null;\n                        break;\n                    }\n                }\n            }\n\n            if (!parentContainer && container) {\n                // Getting out from the current spatnav container\n                const candidates = filteredCandidates(\n                    eventTarget,\n                    getSpatialNavigationCandidates(container, option),\n                    dir,\n                    container,\n                );\n\n                // 9\n                if (Array.isArray(candidates) && candidates.length > 0) {\n                    bestNextTarget = eventTarget.spatialNavigationSearch(dir, {\n                        candidates,\n                        container,\n                    });\n                    if (bestNextTarget) {\n                        return findCandidate ? candidates : bestNextTarget;\n                    }\n                }\n            }\n\n            if (canScroll(container, dir)) {\n                bestNextTarget = eventTarget;\n                return bestNextTarget;\n            }\n        }\n\n        return {\n            isContainer,\n            isScrollContainer,\n            isVisibleInScroller,\n            findCandidates: findTarget.bind(null, true),\n            findNextTarget: findTarget.bind(null, false),\n            getDistanceFromTarget: (element, candidateElement, dir) => {\n                if ((isContainer(element) || element.nodeName === 'BODY') && !(element.nodeName === 'INPUT')) {\n                    if (getSpatialNavigationCandidates(element).includes(candidateElement)) {\n                        return getInnerDistance(\n                            getBoundingClientRect(element),\n                            getBoundingClientRect(candidateElement),\n                            dir,\n                        );\n                    }\n                }\n                return getDistance(getBoundingClientRect(element), getBoundingClientRect(candidateElement), dir);\n            },\n        };\n    }\n\n    /**\n     * Makes to use the experimental APIs.\n     * @function enableExperimentalAPIs\n     * @param option {boolean} - If it is true, the experimental APIs can be used or it cannot.\n     */\n    function enableExperimentalAPIs(option) {\n        const currentKeyMode = window.__spatialNavigation__ && window.__spatialNavigation__.keyMode;\n        window.__spatialNavigation__ =\n            option === false ? getInitialAPIs() : Object.assign(getInitialAPIs(), getExperimentalAPI());\n        window.__spatialNavigation__.keyMode = currentKeyMode;\n        Object.seal(window.__spatialNavigation__);\n    }\n\n    /**\n     * Set the environment for using the spatial navigation polyfill.\n     * @function getInitialAPIs\n     */\n    function getInitialAPIs() {\n        return {\n            enableExperimentalAPIs,\n            get keyMode() {\n                return this._keymode ? this._keymode : 'ARROW';\n            },\n            set keyMode(mode) {\n                this._keymode = ['SHIFTARROW', 'ARROW', 'NONE'].includes(mode) ? mode : 'ARROW';\n            },\n            setStartingPoint: function (x, y) {\n                startingPoint = x && y ? { x, y } : null;\n            },\n        };\n    }\n\n    initiateSpatialNavigation();\n    enableExperimentalAPIs(true);\n\n    window.addEventListener('load', () => {\n        spatialNavigationHandler();\n    });\n})();\n\nconst setDefaultScrollTo = () => {\n    let currentSpatialNavigationContainer = null;\n\n    function isElementInViewport(el) {\n        const rect = el.getBoundingClientRect();\n        return (\n            rect.top >= 0 &&\n            rect.left >= 0 &&\n            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n            rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n        );\n    }\n\n\n    document.addEventListener('navbeforefocus', (e) => {\n        if (e.target instanceof HTMLElement) {\n            e.preventDefault();\n\n            let { target } = e;\n\n            // focus on the first element when changing spatnav container\n            const nextSpatialNavigationContainer = target.getSpatialNavigationContainer();\n\n            if (currentSpatialNavigationContainer && currentSpatialNavigationContainer !== nextSpatialNavigationContainer) {\n                if (nextSpatialNavigationContainer.__lastElementFocused) {\n                    target = nextSpatialNavigationContainer.__lastElementFocused;\n                } else {\n                    [target] = nextSpatialNavigationContainer.focusableAreas({ mode: 'all' });\n                }\n                // target.focus();\n            }\n\n            currentSpatialNavigationContainer = nextSpatialNavigationContainer;\n            currentSpatialNavigationContainer.__lastElementFocused = target;\n\n            requestAnimationFrame(async () => {\n                target.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });\n                // if (isElementInViewport(target)) {\n                //     target.focus();\n                // }\n\n                await new Promise((resolve) => {\n                    const intersectionObserver = new IntersectionObserver(\n                        ([entry]) => {\n                            if (entry.isIntersecting) {\n                                resolve();\n                            }\n                        },\n                        {\n                            threshold: 1,\n                        },\n                    );\n                    intersectionObserver.observe(target);\n                });\n\n                target.focus();\n            });\n        }\n    });\n};\n\n//   `Enter` aka ` OK`  \ndocument.addEventListener('keyup', (event) => {\n    if (event.keyCode === 13) {\n        event.preventDefault();\n        if (document.activeElement) {\n            document.activeElement.click();\n        }\n    }\n});\n\n// EXTERNAL MODULE: ./node_modules/@sberdevices/assistant-client/dist/index.js\nvar dist = __webpack_require__(\"NbAz\");\n\n// EXTERNAL MODULE: ./node_modules/next/router.js\nvar router = __webpack_require__(\"20a2\");\nvar router_default = /*#__PURE__*/__webpack_require__.n(router);\n\n// EXTERNAL MODULE: ./src/consts/routes.ts\nvar routes = __webpack_require__(\"//ZD\");\n\n// CONCATENATED MODULE: ./src/hooks/useAssistant.ts\n\n\n\n\n\nvar useAssistant_initialize = function initialize() {\n  var getState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n    return {};\n  };\n  return Object(dist[\"createAssistant\"])({\n    getState: getState\n  });\n};\n\nvar useAssistant_processMessage = function processMessage(message) {\n  var _message$action;\n\n  var map = {\n    // eslint-disable-next-line\n    goto_catalog: routes[\"a\" /* Route */].INDEX,\n    // eslint-disable-next-line    \n    goto_mohito: routes[\"a\" /* Route */].MOHITO,\n    // eslint-disable-next-line\n    goto_tropical: routes[\"a\" /* Route */].TROPICAL,\n    // eslint-disable-next-line\n    goto_orangelemonade: routes[\"a\" /* Route */].ORANGE_LEMONADE,\n    // eslint-disable-next-line\n    goto_mintmilk: routes[\"a\" /* Route */].MINT_MILK,\n    // eslint-disable-next-line\n    goto_iceberg: routes[\"a\" /* Route */].ICEBERG,\n    // eslint-disable-next-line\n    goto_chokomilk: routes[\"a\" /* Route */].CHOKOMILK,\n    // eslint-disable-next-line\n    goto_slad: routes[\"a\" /* Route */].SLAD,\n    // eslint-disable-next-line\n    goto_champ: routes[\"a\" /* Route */].CHAMP,\n    // eslint-disable-next-line\n    goto_ale: routes[\"a\" /* Route */].ALE,\n    // eslint-disable-next-line\n    goto_klement: routes[\"a\" /* Route */].KLEMENT,\n    // eslint-disable-next-line\n    goto_prostuda: routes[\"a\" /* Route */].PROSTUDA,\n    // eslint-disable-next-line\n    goto_gogol: routes[\"a\" /* Route */].GOGOL\n  }; // @ts-ignore\n\n  var route = map[message === null || message === void 0 ? void 0 : (_message$action = message.action) === null || _message$action === void 0 ? void 0 : _message$action.type];\n\n  if (route) {\n    var _Router$router;\n\n    (_Router$router = router_default.a.router) === null || _Router$router === void 0 ? void 0 : _Router$router.push(route);\n  }\n};\n\nvar useAssistant_useAssistant = function useAssistant() {\n  Object(external_React_[\"useEffect\"])(function () {\n    var assistant = useAssistant_initialize();\n    assistant.on('data', useAssistant_processMessage);\n  }, []);\n};\n// EXTERNAL MODULE: ./node_modules/next/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js\nvar taggedTemplateLiteral = __webpack_require__(\"jT3O\");\n\n// EXTERNAL MODULE: ./node_modules/@sberdevices/plasma-ui/es/index.js\nvar es = __webpack_require__(\"Gv25\");\n\n// EXTERNAL MODULE: ./node_modules/@sberdevices/plasma-core/components/Grid/index.js\nvar Grid = __webpack_require__(\"UloT\");\n\n// EXTERNAL MODULE: ./node_modules/next/link.js\nvar next_link = __webpack_require__(\"YFqc\");\nvar link_default = /*#__PURE__*/__webpack_require__.n(next_link);\n\n// EXTERNAL MODULE: ./node_modules/styled-components/dist/styled-components.browser.esm.js\nvar styled_components_browser_esm = __webpack_require__(\"vOnD\");\n\n// EXTERNAL MODULE: ./src/components/Img.tsx\nvar Img = __webpack_require__(\"eK0j\");\n\n// EXTERNAL MODULE: ./src/components/MyHeader.tsx\nvar MyHeader = __webpack_require__(\"YAxo\");\n\n// CONCATENATED MODULE: ./src/components/Catalog.tsx\n\nvar __jsx = external_React_default.a.createElement;\n\nfunction _templateObject5() {\n  var data = Object(taggedTemplateLiteral[\"a\" /* default */])([\"\\n    padding-left: \", \"px;\\n\"]);\n\n  _templateObject5 = function _templateObject5() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject4() {\n  var data = Object(taggedTemplateLiteral[\"a\" /* default */])([\"\\n    margin-top: 20px;\\n\"]);\n\n  _templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject3() {\n  var data = Object(taggedTemplateLiteral[\"a\" /* default */])([\"\\n    width: \", \";\\n    display: \", \";\\n\"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = Object(taggedTemplateLiteral[\"a\" /* default */])([\"\\n    color: rgba(255, 255, 255, 0.56);\\n    margin-top: 8px;\\n    margin-bottom: 2px;\\n    width: \", \";\\n    display: \", \";\\n\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = Object(taggedTemplateLiteral[\"a\" /* default */])([\"\\n    margin-bottom: \", \"px;\\n\\n    height: \", \"px;\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\n\n\n\n\n\n\n\n\n\nvar heightMap = {\n  sberPortal: 247,\n  sberBox: 336,\n  mobile: 165\n};\nvar StyledCard = Object(styled_components_browser_esm[\"default\"])(es[\"Card\"])(_templateObject(), Object(deviceDetection[\"detectDevice\"])() === 'mobile' ? 8 : 32, heightMap[Object(deviceDetection[\"detectDevice\"])()]);\nvar StyledBody1 = Object(styled_components_browser_esm[\"default\"])(es[\"Body1\"])(_templateObject2(), Object(deviceDetection[\"isSberPortal\"])() ? '100px' : '100%', Object(deviceDetection[\"isSberPortal\"])() ? 'inline-block' : 'block');\nvar StyledBody3 = Object(styled_components_browser_esm[\"default\"])(es[\"Body3\"])(_templateObject3(), Object(deviceDetection[\"isSberPortal\"])() ? 'calc(100% - 100px)' : '100%', Object(deviceDetection[\"isSberPortal\"])() ? 'inline-block' : 'block');\nvar MarginTop = styled_components_browser_esm[\"default\"].div(_templateObject4());\nvar paddingLeft = {\n  sberPortal: 12,\n  sberBox: 52,\n  mobile: 0\n};\nvar RightCol = Object(styled_components_browser_esm[\"default\"])(es[\"Col\"])(_templateObject5(), paddingLeft[Object(deviceDetection[\"detectDevice\"])()]);\n\nvar Catalog_Half = function Half(_ref) {\n  var children = _ref.children;\n  return __jsx(es[\"Col\"], {\n    sizeS: 4,\n    sizeM: 3,\n    sizeL: 4,\n    sizeXL: 6\n  }, children);\n};\n\nvar Catalog_initializeAssistant = function initializeAssistant(getState) {\n  if (false) { var _process$env$REACT_AP; }\n\n  return Object(dist[\"createAssistant\"])({\n    getState: getState\n  });\n};\n\nvar Catalog_Catalog = function Catalog() {\n  var _window$AssistantHost;\n\n  var assistantStateRef = Object(external_React_[\"useRef\"])();\n  var assistantRef = Object(external_React_[\"useRef\"])();\n  Object(external_React_[\"useEffect\"])(function () {\n    assistantRef.current = Catalog_initializeAssistant(function () {\n      return assistantStateRef.current;\n    });\n    assistantRef.current.on(\"data\", function (_ref2) {\n      var action = _ref2.action;\n\n      if (action) {}\n    });\n  }, []);\n  return __jsx(external_React_default.a.Fragment, null, __jsx(MyHeader[\"a\" /* default */], {\n    label: \"\\u0411\\u0435\\u0437\\u0430\\u043B\\u043A\\u043E\\u0433\\u043E\\u043B\\u044C\\u043D\\u044B\\u0435 \\u043A\\u043E\\u043A\\u0442\\u0435\\u0439\\u043B\\u0438\",\n    onBack: (_window$AssistantHost = window.AssistantHost) === null || _window$AssistantHost === void 0 ? void 0 : _window$AssistantHost.close\n  }), __jsx(es[\"Container\"], null, __jsx(\"div\", {\n    style: {\n      marginLeft: 'auto',\n      marginRight: 'auto'\n    }\n  }, __jsx(Grid[\"Row\"], null, __jsx(es[\"Col\"], {\n    sizeS: 4,\n    sizeM: 4,\n    sizeL: 8,\n    sizeXL: 8\n  }, __jsx(Grid[\"Row\"], null, __jsx(Catalog_Half, null, __jsx(link_default.a, {\n    href: routes[\"a\" /* Route */].MOHITO\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true,\n    onChange: function onChange() {\n      var _assistantRef$current;\n\n      return (_assistantRef$current = assistantRef.current) === null || _assistantRef$current === void 0 ? void 0 : _assistantRef$current.sendData({\n        action: {\n          type: 'MOHITO'\n        }\n      });\n    }\n  }, __jsx(es[\"CardBody\"], null, __jsx(Img[\"a\" /* default */], {\n    src: Object(deviceDetection[\"detectDevice\"])() === 'mobile' ? '/mohito.jpg' : '/mohito.jpg'\n  }), __jsx(es[\"CardContent\"], {\n    cover: true\n  }, __jsx(es[\"TextBox\"], null, __jsx(es[\"TextBoxBigTitle\"], null, \"\\u041C\\u043E\\u0445\\u0438\\u0442\\u043E\"))))))), __jsx(Catalog_Half, null, __jsx(link_default.a, {\n    href: routes[\"a\" /* Route */].TROPICAL\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(es[\"CardBody\"], null, __jsx(Img[\"a\" /* default */], {\n    src: Object(deviceDetection[\"detectDevice\"])() === 'mobile' ? '/tropical.jpeg' : '/tropical.jpeg'\n  }), __jsx(es[\"CardContent\"], {\n    cover: true\n  }, __jsx(es[\"TextBox\"], null, __jsx(es[\"TextBoxBigTitle\"], null, \"\\u0422\\u0440\\u043E\\u043F\\u0438\\u0447\\u0435\\u0441\\u043A\\u0438\\u0439\"))))))), __jsx(Catalog_Half, null, __jsx(link_default.a, {\n    href: routes[\"a\" /* Route */].ORANGE_LEMONADE\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(es[\"CardBody\"], null, __jsx(Img[\"a\" /* default */], {\n    src: Object(deviceDetection[\"detectDevice\"])() === 'mobile' ? '/orange_lemonade.jpeg' : '/orange_lemonade.jpeg'\n  }), __jsx(es[\"CardContent\"], {\n    cover: true\n  }, __jsx(es[\"TextBox\"], null, __jsx(es[\"TextBoxBigTitle\"], null, \"\\u0410\\u043F\\u0435\\u043B\\u044C\\u0441\\u0438\\u043D\\u043E\\u0432\\u044B\\u0439 \\u043B\\u0438\\u043C\\u043E\\u043D\\u0430\\u0434\"))))))), __jsx(Catalog_Half, null, __jsx(link_default.a, {\n    href: routes[\"a\" /* Route */].MINT_MILK\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(es[\"CardBody\"], null, __jsx(Img[\"a\" /* default */], {\n    src: Object(deviceDetection[\"detectDevice\"])() === 'mobile' ? '/myatnoe_moloko_1.jpeg' : '/myatnoe_moloko_1.jpeg'\n  }), __jsx(es[\"CardContent\"], {\n    cover: true\n  }, __jsx(es[\"TextBox\"], null, __jsx(es[\"TextBoxBigTitle\"], null, \"\\u041C\\u044F\\u0442\\u043D\\u043E\\u0435 \\u043C\\u043E\\u043B\\u043E\\u043A\\u043E\")))))))), __jsx(Grid[\"Row\"], null, __jsx(Catalog_Half, null, __jsx(link_default.a, {\n    href: routes[\"a\" /* Route */].ICEBERG\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(es[\"CardBody\"], null, __jsx(Img[\"a\" /* default */], {\n    src: Object(deviceDetection[\"detectDevice\"])() === 'mobile' ? '/iceverg.jpeg' : '/iceverg.jpeg'\n  }), __jsx(es[\"CardContent\"], {\n    cover: true\n  }, __jsx(es[\"TextBox\"], null, __jsx(es[\"TextBoxBigTitle\"], null, \"\\u0410\\u0439\\u0441\\u0431\\u0435\\u0440\\u0433 \\u0432 \\u043E\\u043A\\u0435\\u0430\\u043D\\u0435\"))))))), __jsx(Catalog_Half, null, __jsx(link_default.a, {\n    href: routes[\"a\" /* Route */].CHOKOMILK\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(es[\"CardBody\"], null, __jsx(Img[\"a\" /* default */], {\n    src: Object(deviceDetection[\"detectDevice\"])() === 'mobile' ? '/chokomilk.jpeg' : '/chokomilk.jpeg'\n  }), __jsx(es[\"CardContent\"], {\n    cover: true\n  }, __jsx(es[\"TextBox\"], null, __jsx(es[\"TextBoxBigTitle\"], null, \"\\u041C\\u043E\\u043B\\u043E\\u0447\\u043D\\u043E-\\u0448\\u043E\\u043A\\u043E\\u043B\\u0430\\u0434\\u043D\\u044B\\u0439 \\u043A\\u043E\\u043A\\u0442\\u0435\\u0439\\u043B\\u044C\"))))))), __jsx(Catalog_Half, null, __jsx(link_default.a, {\n    href: routes[\"a\" /* Route */].SLAD\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(es[\"CardBody\"], null, __jsx(Img[\"a\" /* default */], {\n    src: Object(deviceDetection[\"detectDevice\"])() === 'mobile' ? '/slad.png' : '/slad.png'\n  }), __jsx(es[\"CardContent\"], {\n    cover: true\n  }, __jsx(es[\"TextBox\"], null, __jsx(es[\"TextBoxBigTitle\"], null, \"\\u0421\\u043B\\u0430\\u0434\\u043A\\u043E\\u0435\\u0436\\u043A\\u0430\"))))))), __jsx(Catalog_Half, null, __jsx(link_default.a, {\n    href: routes[\"a\" /* Route */].CHAMP\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(es[\"CardBody\"], null, __jsx(Img[\"a\" /* default */], {\n    src: Object(deviceDetection[\"detectDevice\"])() === 'mobile' ? '/champ.jpeg' : '/champ.jpeg'\n  }), __jsx(es[\"CardContent\"], {\n    cover: true\n  }, __jsx(es[\"TextBox\"], null, __jsx(es[\"TextBoxBigTitle\"], null, \"\\u0424\\u0430\\u043B\\u044C\\u0448\\u0438\\u0432\\u043E\\u0435 \\u0448\\u0430\\u043C\\u043F\\u0430\\u043D\\u0441\\u043A\\u043E\\u0435\")))))))), __jsx(Grid[\"Row\"], null, __jsx(Catalog_Half, null, __jsx(link_default.a, {\n    href: routes[\"a\" /* Route */].ALE\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(es[\"CardBody\"], null, __jsx(Img[\"a\" /* default */], {\n    src: Object(deviceDetection[\"detectDevice\"])() === 'mobile' ? '/ale.jpeg' : '/ale.jpeg'\n  }), __jsx(es[\"CardContent\"], {\n    cover: true\n  }, __jsx(es[\"TextBox\"], null, __jsx(es[\"TextBoxBigTitle\"], null, \"\\u0418\\u043C\\u0431\\u0438\\u0440\\u043D\\u044B\\u0439 \\u044D\\u043B\\u044C\"))))))), __jsx(Catalog_Half, null, __jsx(link_default.a, {\n    href: routes[\"a\" /* Route */].KLEMENT\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(es[\"CardBody\"], null, __jsx(Img[\"a\" /* default */], {\n    src: Object(deviceDetection[\"detectDevice\"])() === 'mobile' ? '/klement.jpeg' : '/klement.jpeg'\n  }), __jsx(es[\"CardContent\"], {\n    cover: true\n  }, __jsx(es[\"TextBox\"], null, __jsx(es[\"TextBoxBigTitle\"], null, \"\\u0421\\u0435\\u043D\\u0442-\\u041A\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\"))))))), __jsx(Catalog_Half, null, __jsx(link_default.a, {\n    href: routes[\"a\" /* Route */].PROSTUDA\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(es[\"CardBody\"], null, __jsx(Img[\"a\" /* default */], {\n    src: Object(deviceDetection[\"detectDevice\"])() === 'mobile' ? '/prostuda.jpeg' : '/prostuda.jpeg'\n  }), __jsx(es[\"CardContent\"], {\n    cover: true\n  }, __jsx(es[\"TextBox\"], null, __jsx(es[\"TextBoxBigTitle\"], null, \"\\u0423\\u0434\\u0430\\u0440 \\u043F\\u043E \\u043F\\u0440\\u043E\\u0441\\u0442\\u0443\\u0434\\u0435\"))))))), __jsx(Catalog_Half, null, __jsx(link_default.a, {\n    href: routes[\"a\" /* Route */].GOGOL\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(es[\"CardBody\"], null, __jsx(Img[\"a\" /* default */], {\n    src: Object(deviceDetection[\"detectDevice\"])() === 'mobile' ? '/gogol.jpeg' : '/gogol.jpeg'\n  }), __jsx(es[\"CardContent\"], {\n    cover: true\n  }, __jsx(es[\"TextBox\"], null, __jsx(es[\"TextBoxBigTitle\"], null, \"\\u0413\\u043E\\u0433\\u043E\\u043B\\u044C-\\u043C\\u043E\\u0433\\u043E\\u043B\\u044C\")))))))))))));\n};\n\n/* harmony default export */ var components_Catalog = (Catalog_Catalog);\n// EXTERNAL MODULE: ./src/components/Layout.tsx + 1 modules\nvar Layout = __webpack_require__(\"soUV\");\n\n// CONCATENATED MODULE: ./src/components/Root.tsx\nvar Root_jsx = external_React_default.a.createElement;\n\n\n\n\n\n\nvar Root_Root = function Root() {\n  useAssistant_useAssistant();\n  return Root_jsx(Layout[\"b\" /* default */], {\n    noPadding: Object(deviceDetection[\"isSberPortal\"])()\n  }, Root_jsx(components_Catalog, null));\n};\n/* harmony default export */ var components_Root = __webpack_exports__[\"default\"] = (Root_Root);\n\n/***/ }),\n\n/***/ \"YFqc\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(\"cTJO\")\n\n\n/***/ }),\n\n/***/ \"cTJO\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _slicedToArray = __webpack_require__(\"zoAU\");\n\nvar _interopRequireWildcard = __webpack_require__(\"7KCV\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _react = _interopRequireWildcard(__webpack_require__(\"cDcd\"));\n\nvar _router = __webpack_require__(\"elyg\");\n\nvar _router2 = __webpack_require__(\"nOHt\");\n\nvar _useIntersection = __webpack_require__(\"vNVm\");\n\nvar prefetched = {};\n\nfunction prefetch(router, href, as, options) {\n  if ( false || !router) return;\n  if (!(0, _router.isLocalURL)(href)) return; // Prefetch the JSON page if asked (only in the client)\n  // We need to handle a prefetch error here since we may be\n  // loading with priority which can reject but we don't\n  // want to force navigation since this is only a prefetch\n\n  router.prefetch(href, as, options).catch(function (err) {\n    if (false) {}\n  });\n  var curLocale = options && typeof options.locale !== 'undefined' ? options.locale : router && router.locale; // Join on an invalid URI character\n\n  prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')] = true;\n}\n\nfunction isModifiedEvent(event) {\n  var target = event.currentTarget.target;\n  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n  event.nativeEvent && event.nativeEvent.which === 2;\n}\n\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale) {\n  var nodeName = e.currentTarget.nodeName;\n\n  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router.isLocalURL)(href))) {\n    // ignore click for browsers default behavior\n    return;\n  }\n\n  e.preventDefault(); //  avoid scroll for urls with anchor refs\n\n  if (scroll == null) {\n    scroll = as.indexOf('#') < 0;\n  } // replace state instead of push if prop is present\n\n\n  router[replace ? 'replace' : 'push'](href, as, {\n    shallow: shallow,\n    locale: locale,\n    scroll: scroll\n  });\n}\n\nfunction Link(props) {\n  if (false) { var hasWarned, optionalProps, optionalPropsGuard, requiredProps, requiredPropsGuard, createPropError; }\n\n  var p = props.prefetch !== false;\n  var router = (0, _router2.useRouter)();\n  var pathname = router && router.pathname || '/';\n\n  var _react$default$useMem = _react.default.useMemo(function () {\n    var _ref = (0, _router.resolveHref)(pathname, props.href, true),\n        _ref2 = _slicedToArray(_ref, 2),\n        resolvedHref = _ref2[0],\n        resolvedAs = _ref2[1];\n\n    return {\n      href: resolvedHref,\n      as: props.as ? (0, _router.resolveHref)(pathname, props.as) : resolvedAs || resolvedHref\n    };\n  }, [pathname, props.href, props.as]),\n      href = _react$default$useMem.href,\n      as = _react$default$useMem.as;\n\n  var children = props.children,\n      replace = props.replace,\n      shallow = props.shallow,\n      scroll = props.scroll,\n      locale = props.locale; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag\n\n  if (typeof children === 'string') {\n    children = /*#__PURE__*/_react.default.createElement(\"a\", null, children);\n  } // This will return the first child, if multiple are provided it will throw an error\n\n\n  var child = _react.Children.only(children);\n\n  var childRef = child && typeof child === 'object' && child.ref;\n\n  var _ref3 = (0, _useIntersection.useIntersection)({\n    rootMargin: '200px'\n  }),\n      _ref4 = _slicedToArray(_ref3, 2),\n      setIntersectionRef = _ref4[0],\n      isVisible = _ref4[1];\n\n  var setRef = _react.default.useCallback(function (el) {\n    setIntersectionRef(el);\n\n    if (childRef) {\n      if (typeof childRef === 'function') childRef(el);else if (typeof childRef === 'object') {\n        childRef.current = el;\n      }\n    }\n  }, [childRef, setIntersectionRef]);\n\n  (0, _react.useEffect)(function () {\n    var shouldPrefetch = isVisible && p && (0, _router.isLocalURL)(href);\n    var curLocale = typeof locale !== 'undefined' ? locale : router && router.locale;\n    var isPrefetched = prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')];\n\n    if (shouldPrefetch && !isPrefetched) {\n      prefetch(router, href, as, {\n        locale: curLocale\n      });\n    }\n  }, [as, href, isVisible, locale, p, router]);\n  var childProps = {\n    ref: setRef,\n    onClick: function onClick(e) {\n      if (child.props && typeof child.props.onClick === 'function') {\n        child.props.onClick(e);\n      }\n\n      if (!e.defaultPrevented) {\n        linkClicked(e, router, href, as, replace, shallow, scroll, locale);\n      }\n    }\n  };\n\n  childProps.onMouseEnter = function (e) {\n    if (!(0, _router.isLocalURL)(href)) return;\n\n    if (child.props && typeof child.props.onMouseEnter === 'function') {\n      child.props.onMouseEnter(e);\n    }\n\n    prefetch(router, href, as, {\n      priority: true\n    });\n  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n  // defined, we specify the current 'href', so that repetition is not needed by the user\n\n\n  if (props.passHref || child.type === 'a' && !('href' in child.props)) {\n    var curLocale = typeof locale !== 'undefined' ? locale : router && router.locale; // we only render domain locales if we are currently on a domain locale\n    // so that locale links are still visitable in development/preview envs\n\n    var localeDomain = router && router.isLocaleDomain && (0, _router.getDomainLocale)(as, curLocale, router && router.locales, router && router.domainLocales);\n    childProps.href = localeDomain || (0, _router.addBasePath)((0, _router.addLocale)(as, curLocale, router && router.defaultLocale));\n  }\n\n  return /*#__PURE__*/_react.default.cloneElement(child, childProps);\n}\n\nvar _default = Link;\nexports.default = _default;\n\n/***/ }),\n\n/***/ \"eK0j\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var C_Users_Professional_Documents_summer_drink_main_node_modules_next_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"HALo\");\n/* harmony import */ var C_Users_Professional_Documents_summer_drink_main_node_modules_next_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"jT3O\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"cDcd\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"vOnD\");\n\n\nvar __jsx = react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement;\n\nfunction _templateObject() {\n  var data = Object(C_Users_Professional_Documents_summer_drink_main_node_modules_next_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])([\"\\n    background: url(\", \") no-repeat center center;\\n    background-size: cover;\\n    width: \", \";\\n    height: \", \";\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\n\n\nvar StyledImage = styled_components__WEBPACK_IMPORTED_MODULE_3__[\"default\"].div(_templateObject(), function (_ref) {\n  var src = _ref.src;\n  return src;\n}, function (_ref2) {\n  var width = _ref2.width;\n  return width ? \"\".concat(width, \"px\") : '100%';\n}, function (_ref3) {\n  var height = _ref3.height;\n  return height ? \"\".concat(height, \"px\") : '100%';\n});\n\nvar Img = function Img(_ref4) {\n  var props = Object(C_Users_Professional_Documents_summer_drink_main_node_modules_next_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])({}, _ref4);\n\n  return __jsx(StyledImage, props);\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Img);\n\n/***/ }),\n\n/***/ \"vNVm\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _slicedToArray = __webpack_require__(\"zoAU\");\n\nexports.__esModule = true;\nexports.useIntersection = useIntersection;\n\nvar _react = __webpack_require__(\"cDcd\");\n\nvar _requestIdleCallback = __webpack_require__(\"0G5g\");\n\nvar hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';\n\nfunction useIntersection(_ref) {\n  var rootMargin = _ref.rootMargin,\n      disabled = _ref.disabled;\n  var isDisabled = disabled || !hasIntersectionObserver;\n  var unobserve = (0, _react.useRef)();\n\n  var _ref2 = (0, _react.useState)(false),\n      _ref3 = _slicedToArray(_ref2, 2),\n      visible = _ref3[0],\n      setVisible = _ref3[1];\n\n  var setRef = (0, _react.useCallback)(function (el) {\n    if (unobserve.current) {\n      unobserve.current();\n      unobserve.current = undefined;\n    }\n\n    if (isDisabled || visible) return;\n\n    if (el && el.tagName) {\n      unobserve.current = observe(el, function (isVisible) {\n        return isVisible && setVisible(isVisible);\n      }, {\n        rootMargin: rootMargin\n      });\n    }\n  }, [isDisabled, rootMargin, visible]);\n  (0, _react.useEffect)(function () {\n    if (!hasIntersectionObserver) {\n      if (!visible) {\n        var idleCallback = (0, _requestIdleCallback.requestIdleCallback)(function () {\n          return setVisible(true);\n        });\n        return function () {\n          return (0, _requestIdleCallback.cancelIdleCallback)(idleCallback);\n        };\n      }\n    }\n  }, [visible]);\n  return [setRef, visible];\n}\n\nfunction observe(element, callback, options) {\n  var _createObserver = createObserver(options),\n      id = _createObserver.id,\n      observer = _createObserver.observer,\n      elements = _createObserver.elements;\n\n  elements.set(element, callback);\n  observer.observe(element);\n  return function unobserve() {\n    elements.delete(element);\n    observer.unobserve(element); // Destroy observer when there's nothing left to watch:\n\n    if (elements.size === 0) {\n      observer.disconnect();\n      observers.delete(id);\n    }\n  };\n}\n\nvar observers = new Map();\n\nfunction createObserver(options) {\n  var id = options.rootMargin || '';\n  var instance = observers.get(id);\n\n  if (instance) {\n    return instance;\n  }\n\n  var elements = new Map();\n  var observer = new IntersectionObserver(function (entries) {\n    entries.forEach(function (entry) {\n      var callback = elements.get(entry.target);\n      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n\n      if (callback && isVisible) {\n        callback(isVisible);\n      }\n    });\n  }, options);\n  observers.set(id, instance = {\n    id: id,\n    observer: observer,\n    elements: elements\n  });\n  return instance;\n}\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["C:\\Users\\Professional\\Documents\\summer-drink-main\\node_modules\\next\\dist\\build\\webpack\\loaders\\next-babel-loader.js??ref--4!C:\\Users\\Professional\\Documents\\summer-drink-main\\src\\consts\\routes.ts","C:\\Users\\Professional\\Documents\\summer-drink-main\\node_modules\\@sberdevices\\spatial-navigation\\polyfill\\spatial-navigation-polyfill.js","C:\\Users\\Professional\\Documents\\summer-drink-main\\node_modules\\next\\dist\\build\\webpack\\loaders\\next-babel-loader.js??ref--4!C:\\Users\\Professional\\Documents\\summer-drink-main\\src\\hooks\\useAssistant.ts","C:\\Users\\Professional\\Documents\\summer-drink-main\\node_modules\\next\\dist\\build\\webpack\\loaders\\next-babel-loader.js??ref--4!C:\\Users\\Professional\\Documents\\summer-drink-main\\src\\components\\Catalog.tsx","C:\\Users\\Professional\\Documents\\summer-drink-main\\node_modules\\next\\dist\\build\\webpack\\loaders\\next-babel-loader.js??ref--4!C:\\Users\\Professional\\Documents\\summer-drink-main\\src\\components\\Root.tsx","C:\\Users\\Professional\\Documents\\summer-drink-main\\node_modules\\next\\link.js","C:\\Users\\Professional\\Documents\\summer-drink-main\\node_modules\\next\\dist\\build\\webpack\\loaders\\next-babel-loader.js??ref--4!C:\\Users\\Professional\\Documents\\summer-drink-main\\node_modules\\next\\dist\\client\\link.js","C:\\Users\\Professional\\Documents\\summer-drink-main\\node_modules\\next\\dist\\build\\webpack\\loaders\\next-babel-loader.js??ref--4!C:\\Users\\Professional\\Documents\\summer-drink-main\\src\\components\\Img.tsx","C:\\Users\\Professional\\Documents\\summer-drink-main\\node_modules\\next\\dist\\build\\webpack\\loaders\\next-babel-loader.js??ref--4!C:\\Users\\Professional\\Documents\\summer-drink-main\\node_modules\\next\\dist\\client\\use-intersection.js"],"names":[],"mappings":";;;;;;AAAA;AAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB,G;;;;;;;;;;;;;;;;;;;;;;AChBvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA,6BAA6B;AAC7B,6BAA6B,6BAA6B;AAC1D,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,aAAa;AACb;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,KAAK;AAClC,mBAAmB,2BAA2B;AAC9C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb,qCAAqC,sBAAsB;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B,mBAAmB,2BAA2B;AAC9C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B,sBAAsB,sBAAsB;AAC5C;AACA,iBAAiB,eAAe;AAChC;AACA,iEAAiE,kBAAkB;AACnF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,6FAA6F,cAAc;AAC3G;AACA,iBAAiB;AACjB,yFAAyF,cAAc;AACvG;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B,mBAAmB,2BAA2B;AAC9C,0BAA0B,eAAe;AACzC,yBAAyB,KAAK;AAC9B,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,mBAAmB,2BAA2B;AAC9C,0BAA0B,eAAe;AACzC,yBAAyB,KAAK;AAC9B,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,0BAA0B,KAAK;AAC/B,0BAA0B,eAAe;AACzC,mBAAmB,2BAA2B;AAC9C,yBAAyB,KAAK;AAC9B,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,0BAA0B,KAAK;AAC/B,0BAA0B,eAAe;AACzC,mBAAmB,2BAA2B;AAC9C,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,0BAA0B,KAAK;AAC/B,0BAA0B,eAAe;AACzC,mBAAmB,2BAA2B;AAC9C,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,KAAK;AAC/B,0BAA0B,eAAe;AACzC,mBAAmB,2BAA2B;AAC9C,gCAAgC,SAAS;AACzC,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,uBAAuB;AAClD;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,sBAAsB,sBAAsB;AAC5C;AACA,iBAAiB,eAAe;AAChC;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,sBAAsB,OAAO;AAC7B,uBAAuB,KAAK;AAC5B,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB,OAAO;AAC9B,iBAAiB,OAAO;AACxB;AACA;AACA,+DAA+D,QAAQ;AACvE;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,KAAK;AAChC,yBAAyB,2BAA2B;AACpD,+BAA+B,2BAA2B;AAC1D;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA,mEAAmE,eAAe;AAClF;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,mEAAmE,eAAe;AAClF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,KAAK;AAC5B,mBAAmB,2BAA2B;AAC9C,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,uBAAuB;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,mBAAmB,2BAA2B;AAC9C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB,mBAAmB,2BAA2B;AAC9C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B,mBAAmB,2BAA2B;AAC9C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB,mBAAmB,2BAA2B;AAC9C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,uBAAuB;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,qBAAqB;AACrB,mBAAmB,2BAA2B;AAC9C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,qBAAqB,MAAM;AAC3B,uBAAuB,QAAQ;AAC/B,mBAAmB,2BAA2B;AAC9C,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,qBAAqB,QAAQ;AAC7B,qBAAqB,QAAQ;AAC7B,mBAAmB,2BAA2B;AAC9C,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,4BAA4B,gBAAgB;AAC5C,6BAA6B,QAAQ;AACrC,mBAAmB,2BAA2B;AAC9C,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B,qBAAqB,QAAQ;AAC7B,mBAAmB,2BAA2B;AAC9C,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B,qBAAqB,QAAQ;AAC7B,mBAAmB,2BAA2B;AAC9C,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C,4BAA4B,gBAAgB;AAC5C,6BAA6B,QAAQ;AACrC,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,sBAAsB,MAAM;AAC5B,sBAAsB,MAAM;AAC5B;AACA,wBAAwB,cAAc,aAAa,cAAc,aAAa;;AAE9E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,qBAAqB,QAAQ;AAC7B,qBAAqB,QAAQ;AAC7B,iBAAiB,iBAAiB;AAClC;AACA,gBAAgB,OAAO;AACvB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB;AACA;AACA,mCAAmC;;AAEnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,iBAAiB,MAAM;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE,aAAa;AACjF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,0CAA0C,OAAO;AACjD,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL,CAAC;;AAEM;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,iBAAiB,SAAS;;AAE1B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,8EAA8E,cAAc;AAC5F;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC,yDAAyD;AAChG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;;AAEjB;AACA,aAAa;AACb;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;A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ACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,IAAI;AACJ;;;AAGA;AACA,qFAAqF;AACrF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2B;;;;;;;;ACrPA;AAAA;AAAA;AAAA;AAAA;AAA2I;AAC4B;AACvK,YAAY,4CAAK;;AAEjB;AACA,aAAa,uLAAsB,uDAAuD,6BAA6B,kBAAkB,mBAAmB;;AAE5J;AACA;AACA;;AAEA;AACA;;AAE0B;AACa;AACvC,kBAAkB,yDAAM;AACxB;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA,cAAc,yKAAQ,GAAG;;AAEzB;AACA;;AAEe,4DAAG,E;;;;;;;;ACjCL;;AAEb,qBAAqB,mBAAO,CAAC,MAAuH;;AAEpJ;AACA;;AAEA,aAAa,mBAAO,CAAC,MAAO;;AAE5B,2BAA2B,mBAAO,CAAC,MAAyB;;AAE5D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,C","file":"x","sourcesContent":["export var Route;\n\n(function (Route) {\n  Route[\"INDEX\"] = \"/\";\n  Route[\"MOHITO\"] = \"/mohito\";\n  Route[\"TROPICAL\"] = \"/tropical\";\n  Route[\"ORANGE_LEMONADE\"] = \"/orange_lemonade\";\n  Route[\"MINT_MILK\"] = \"/mint_milk\";\n  Route[\"ICEBERG\"] = \"/iceberg\";\n  Route[\"CHOKOMILK\"] = \"/chokomilk\";\n  Route[\"SLAD\"] = \"/slad\";\n  Route[\"CHAMP\"] = \"/champ\";\n  Route[\"ALE\"] = \"/ale\";\n  Route[\"KLEMENT\"] = \"/klement\";\n  Route[\"PROSTUDA\"] = \"/prostuda\";\n  Route[\"GOGOL\"] = \"/gogol\";\n})(Route || (Route = {}));","/* eslint-disable */\n\n/* Spatial Navigation Polyfill\n *\n * It follows W3C official specification\n * https://drafts.csswg.org/css-nav-1/\n *\n * Copyright (c) 2018-2019 LG Electronics Inc.\n * https://github.com/WICG/spatial-navigation/polyfill\n *\n * Licensed under the MIT license (MIT)\n */\n\n(function () {\n    // The polyfill must not be executed, if it's already enabled via browser engine or browser extensions.\n    if ('navigate' in window) {\n        return;\n    }\n\n    const ARROW_KEY_CODE = { 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n    const TAB_KEY_CODE = 9;\n    let mapOfBoundRect = null;\n    let startingPoint = null; // Saves spatial navigation starting point\n    let savedSearchOrigin = { element: null, rect: null }; // Saves previous search origin\n    let searchOriginRect = null; // Rect of current search origin\n\n    window.__getSpatNavState = () => {\n        return {\n            mapOfBoundRect,\n            startingPoint,\n            savedSearchOrigin,\n            searchOriginRect,\n        };\n    };\n\n    /**\n     * Initiate the spatial navigation features of the polyfill.\n     * @function initiateSpatialNavigation\n     */\n    function initiateSpatialNavigation() {\n        /*\n         * Bind the standards APIs to be exposed to the window object for authors\n         */\n        window.navigate = navigate;\n        window.Element.prototype.spatialNavigationSearch = spatialNavigationSearch;\n        window.Element.prototype.focusableAreas = focusableAreas;\n        window.Element.prototype.getSpatialNavigationContainer = getSpatialNavigationContainer;\n\n        /*\n         * CSS.registerProperty() from the Properties and Values API\n         * Reference: https://drafts.css-houdini.org/css-properties-values-api/#the-registerproperty-function\n         */\n        if (window.CSS && CSS.registerProperty) {\n            if (\n                window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-contain') ===\n                ''\n            ) {\n                CSS.registerProperty({\n                    name: '--spatial-navigation-contain',\n                    syntax: 'auto | contain',\n                    inherits: false,\n                    initialValue: 'auto',\n                });\n            }\n\n            if (\n                window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-action') === ''\n            ) {\n                CSS.registerProperty({\n                    name: '--spatial-navigation-action',\n                    syntax: 'auto | focus | scroll',\n                    inherits: false,\n                    initialValue: 'auto',\n                });\n            }\n\n            if (\n                window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-function') ===\n                ''\n            ) {\n                CSS.registerProperty({\n                    name: '--spatial-navigation-function',\n                    syntax: 'normal | grid',\n                    inherits: false,\n                    initialValue: 'normal',\n                });\n            }\n        }\n    }\n\n    /**\n     * Add event handlers for the spatial navigation behavior.\n     * This function defines which input methods trigger the spatial navigation behavior.\n     * @function spatialNavigationHandler\n     */\n    function spatialNavigationHandler() {\n        /*\n         * keydown EventListener :\n         * If arrow key pressed, get the next focusing element and send it to focusing controller\n         */\n        window.addEventListener('keydown', (e) => {\n            const currentKeyMode =\n                (parent && parent.__spatialNavigation__ && parent.__spatialNavigation__.keyMode) ||\n                (window.__spatialNavigation__ && window.__spatialNavigation__.keyMode);\n            const eventTarget = document.activeElement;\n            const dir = ARROW_KEY_CODE[e.keyCode];\n\n            if (e.keyCode === TAB_KEY_CODE) {\n                startingPoint = null;\n            }\n\n            if (\n                !currentKeyMode ||\n                currentKeyMode === 'NONE' ||\n                (currentKeyMode === 'SHIFTARROW' && !e.shiftKey) ||\n                (currentKeyMode === 'ARROW' && e.shiftKey) ||\n                e.ctrlKey ||\n                e.metaKey ||\n                e.altKey\n            )\n                return;\n\n            if (!e.defaultPrevented) {\n                let focusNavigableArrowKey = {\n                    left: true,\n                    up: true,\n                    right: true,\n                    down: true,\n                };\n\n                // Edge case (text input, area) : Don't move focus, just navigate cursor in text area\n                if (eventTarget.nodeName === 'INPUT' || eventTarget.nodeName === 'TEXTAREA') {\n                    focusNavigableArrowKey = handlingEditableElement(e);\n                }\n\n                if (focusNavigableArrowKey[dir]) {\n                    e.preventDefault();\n                    mapOfBoundRect = new Map();\n\n                    navigate(dir);\n\n                    mapOfBoundRect = null;\n                    startingPoint = null;\n                }\n            }\n        });\n\n        /*\n         * mouseup EventListener :\n         * If the mouse click a point in the page, the point will be the starting point.\n         * NOTE: Let UA set the spatial navigation starting point based on click\n         */\n        document.addEventListener('mouseup', (e) => {\n            startingPoint = { x: e.clientX, y: e.clientY };\n        });\n\n        /*\n         * focusin EventListener :\n         * When the element get the focus, save it and its DOMRect for resetting the search origin\n         * if it disappears.\n         */\n        window.addEventListener('focusin', (e) => {\n            if (e.target !== window) {\n                savedSearchOrigin.element = e.target;\n                savedSearchOrigin.rect = e.target.getBoundingClientRect();\n            }\n        });\n    }\n\n    /**\n     * Enable the author to trigger spatial navigation programmatically, as if the user had done so manually.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#dom-window-navigate}\n     * @function navigate\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     */\n    function navigate(dir) {\n        // spatial navigation steps\n\n        // 1\n        const searchOrigin = findSearchOrigin();\n        let eventTarget = searchOrigin;\n        let elementFromPosition = null;\n\n        // 2 Optional step, UA defined starting point\n        if (startingPoint) {\n            // if there is a starting point, set eventTarget as the element from position for getting the spatnav container\n            elementFromPosition = document.elementFromPoint(startingPoint.x, startingPoint.y);\n\n            // Use starting point if the starting point isn't inside the focusable element (but not container)\n            // * Starting point is meaningfull when:\n            // 1) starting point is inside the spatnav container\n            // 2) starting point is inside the non-focusable element\n            if (elementFromPosition === null) {\n                elementFromPosition = document.body;\n            }\n            if (isFocusable(elementFromPosition) && !isContainer(elementFromPosition)) {\n                startingPoint = null;\n            } else if (isContainer(elementFromPosition)) {\n                eventTarget = elementFromPosition;\n            } else {\n                eventTarget = elementFromPosition.getSpatialNavigationContainer();\n            }\n        }\n\n        // 4\n        if (eventTarget === window || eventTarget === document || eventTarget === document.documentElement) {\n            eventTarget = document.body || document.documentElement;\n        }\n\n        // 5\n        // At this point, spatialNavigationSearch can be applied.\n        // If startingPoint is either a scroll container or the document,\n        // find the best candidate within startingPoint\n        let container = null;\n        if ((isContainer(eventTarget) || eventTarget.nodeName === 'BODY') && !(eventTarget.nodeName === 'INPUT')) {\n            if (eventTarget.nodeName === 'IFRAME') {\n                eventTarget = eventTarget.contentDocument.documentElement;\n            }\n\n            container = container === window ? document.body : eventTarget;\n            let bestInsideCandidate = null;\n\n            // 5-2\n            if (\n                document.activeElement === searchOrigin ||\n                (document.activeElement === document.body && searchOrigin === document.documentElement)\n            ) {\n                if (getCSSSpatNavAction(eventTarget) === 'scroll') {\n                    if (scrollingController(eventTarget, dir)) return;\n                } else if (getCSSSpatNavAction(eventTarget) === 'focus') {\n                    bestInsideCandidate = eventTarget.spatialNavigationSearch(dir, {\n                        container: eventTarget,\n                        candidates: getSpatialNavigationCandidates(eventTarget, {\n                            mode: 'all',\n                        }),\n                    });\n                    if (focusingController(bestInsideCandidate, dir)) return;\n                } else if (getCSSSpatNavAction(eventTarget) === 'auto') {\n                    bestInsideCandidate = eventTarget.spatialNavigationSearch(dir, {\n                        container: eventTarget,\n                    });\n                    if (focusingController(bestInsideCandidate, dir) || scrollingController(eventTarget, dir)) return;\n                }\n            } else {\n                // when the previous search origin became offscreen\n                container = container.getSpatialNavigationContainer();\n            }\n        }\n\n        // 6\n        // Let container be the nearest ancestor of eventTarget\n        container = eventTarget.getSpatialNavigationContainer();\n        let parentContainer = container.parentElement ? container.getSpatialNavigationContainer() : null;\n\n        // When the container is the viewport of a browsing context\n        if (!parentContainer && window.location !== window.parent.location) {\n            parentContainer = window.parent.document.documentElement;\n        }\n\n        if (getCSSSpatNavAction(container) === 'scroll') {\n            if (scrollingController(container, dir)) return;\n        } else if (getCSSSpatNavAction(container) === 'focus') {\n            navigateChain(eventTarget, container, parentContainer, dir, 'all');\n        } else if (getCSSSpatNavAction(container) === 'auto') {\n            navigateChain(eventTarget, container, parentContainer, dir, 'visible');\n        }\n    }\n\n    /**\n     * Move the focus to the best candidate or do nothing.\n     * @function focusingController\n     * @param bestCandidate {Node} - The best candidate of the spatial navigation\n     * @param dir {SpatialNavigationDirection}- The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function focusingController(bestCandidate, dir) {\n        // 10 & 11\n        // When bestCandidate is found\n        if (bestCandidate) {\n            // When bestCandidate is a focusable element and not a container : move focus\n            /*\n             * [event] navbeforefocus : Fired before spatial or sequential navigation changes the focus.\n             */\n            if (!createSpatNavEvents('beforefocus', bestCandidate, null, dir)) return true;\n\n            const container = bestCandidate.getSpatialNavigationContainer();\n\n            if (container !== window && getCSSSpatNavAction(container) === 'focus') {\n                bestCandidate.focus();\n            } else {\n                bestCandidate.focus({ preventScroll: true });\n            }\n\n            startingPoint = null;\n            return true;\n        }\n\n        // When bestCandidate is not found within the scrollport of a container: Nothing\n        return false;\n    }\n\n    /**\n     * Directionally scroll the scrollable spatial navigation container if it can be manually scrolled more.\n     * @function scrollingController\n     * @param container {Node} - The spatial navigation container which can scroll\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function scrollingController(container, dir) {\n        // If there is any scrollable area among parent elements and it can be manually scrolled, scroll the document\n        if (isScrollable(container, dir) && !isScrollBoundary(container, dir)) {\n            moveScroll(container, dir);\n            return true;\n        }\n\n        // If the spatnav container is document and it can be scrolled, scroll the document\n        if (!container.parentElement && !isHTMLScrollBoundary(container, dir)) {\n            moveScroll(container.ownerDocument.documentElement, dir);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Find the candidates within a spatial navigation container include delegable container.\n     * This function does not search inside delegable container or focusable container.\n     * In other words, this return candidates set is not included focusable elements inside delegable container or focusable container.\n     *\n     * @function getSpatialNavigationCandidates\n     * @param container {Node} - The spatial navigation container\n     * @param option {FocusableAreasOptions} - 'mode' attribute takes 'visible' or 'all' for searching the boundary of focusable elements.\n     *                                          Default value is 'visible'.\n     * @returns {sequence<Node>} candidate elements within the container\n     */\n    function getSpatialNavigationCandidates(container, option = { mode: 'visible' }) {\n        let candidates = [];\n\n        if (container.childElementCount > 0) {\n            if (!container.parentElement) {\n                container = container.getElementsByTagName('body')[0] || document.body;\n            }\n            const children = container.children;\n            for (const elem of children) {\n                if (isDelegableContainer(elem)) {\n                    candidates.push(elem);\n                } else if (isFocusable(elem)) {\n                    candidates.push(elem);\n\n                    if (!isContainer(elem) && elem.childElementCount) {\n                        candidates = candidates.concat(getSpatialNavigationCandidates(elem, { mode: 'all' }));\n                    }\n                } else if (elem.childElementCount) {\n                    candidates = candidates.concat(getSpatialNavigationCandidates(elem, { mode: 'all' }));\n                }\n            }\n        }\n\n        return option.mode === 'all' ? candidates : candidates.filter(isVisible);\n    }\n\n    /**\n     * Find the candidates among focusable elements within a spatial navigation container from the search origin (currently focused element)\n     * depending on the directional information.\n     * @function getFilteredSpatialNavigationCandidates\n     * @param element {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation without the directional information\n     * @param container {Node} - The spatial navigation container\n     * @returns {Node} The candidates for spatial navigation considering the directional information\n     */\n    function getFilteredSpatialNavigationCandidates(element, dir, candidates, container) {\n        const targetElement = element;\n        // Removed below line due to a bug. (iframe body rect is sometime weird.)\n        // const targetElement = (element.nodeName === 'IFRAME') ? element.contentDocument.body : element;\n        // If the container is unknown, get the closest container from the element\n        container = container || targetElement.getSpatialNavigationContainer();\n\n        // If the candidates is unknown, find candidates\n        // 5-1\n        candidates = !candidates || candidates.length <= 0 ? getSpatialNavigationCandidates(container) : candidates;\n        return filteredCandidates(targetElement, candidates, dir, container);\n    }\n\n    /**\n     * Find the best candidate among the candidates within the container from the search origin (currently focused element)\n     * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-spatialnavigationsearch}\n     * @function spatialNavigationSearch\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param container {Node} - The spatial navigation container\n     * @returns {Node} The best candidate which will gain the focus\n     */\n    function spatialNavigationSearch(dir, args) {\n        const targetElement = this;\n        let internalCandidates = [];\n        let externalCandidates = [];\n        let insideOverlappedCandidates = getOverlappedCandidates(targetElement);\n        let bestTarget;\n\n        // Set default parameter value\n        if (!args) args = {};\n\n        const defaultContainer = targetElement.getSpatialNavigationContainer();\n        let defaultCandidates = getSpatialNavigationCandidates(defaultContainer);\n        const container = args.container || defaultContainer;\n        if (args.container && defaultContainer.contains(args.container)) {\n            defaultCandidates = defaultCandidates.concat(getSpatialNavigationCandidates(container));\n        }\n        const candidates =\n            args.candidates && args.candidates.length > 0\n                ? args.candidates.filter((candidate) => container.contains(candidate))\n                : defaultCandidates.filter((candidate) => container.contains(candidate) && container !== candidate);\n\n        // Find the best candidate\n        // 5\n        // If startingPoint is either a scroll container or the document,\n        // find the best candidate within startingPoint\n        if (candidates && candidates.length > 0) {\n            // Divide internal or external candidates\n            candidates.forEach((candidate) => {\n                if (candidate !== targetElement) {\n                    (targetElement.contains(candidate) && targetElement !== candidate\n                        ? internalCandidates\n                        : externalCandidates\n                    ).push(candidate);\n                }\n            });\n\n            // include overlapped element to the internalCandidates\n            let fullyOverlapped = insideOverlappedCandidates.filter(\n                (candidate) => !internalCandidates.includes(candidate),\n            );\n            let overlappedContainer = candidates.filter(\n                (candidate) => isContainer(candidate) && isEntirelyVisible(targetElement, candidate),\n            );\n            let overlappedByParent = overlappedContainer\n                .map((elm) => elm.focusableAreas())\n                .flat()\n                .filter((candidate) => candidate !== targetElement);\n\n            internalCandidates = internalCandidates\n                .concat(fullyOverlapped)\n                .filter((candidate) => container.contains(candidate));\n            externalCandidates = externalCandidates\n                .concat(overlappedByParent)\n                .filter((candidate) => container.contains(candidate));\n\n            // Filter external Candidates\n            if (externalCandidates.length > 0) {\n                externalCandidates = getFilteredSpatialNavigationCandidates(\n                    targetElement,\n                    dir,\n                    externalCandidates,\n                    container,\n                );\n            }\n\n            // If there isn't search origin element but search orgin rect exist  (search origin isn't in the layout case)\n            if (searchOriginRect) {\n                bestTarget = selectBestCandidate(\n                    targetElement,\n                    getFilteredSpatialNavigationCandidates(targetElement, dir, internalCandidates, container),\n                    dir,\n                );\n            }\n\n            if (internalCandidates && internalCandidates.length > 0 && !(targetElement.nodeName === 'INPUT')) {\n                bestTarget = selectBestCandidateFromEdge(targetElement, internalCandidates, dir);\n            }\n\n            bestTarget = bestTarget || selectBestCandidate(targetElement, externalCandidates, dir);\n\n            if (bestTarget && isDelegableContainer(bestTarget)) {\n                // if best target is delegable container, then find descendants candidate inside delegable container.\n                const innerTarget = getSpatialNavigationCandidates(bestTarget, {\n                    mode: 'all',\n                });\n                const descendantsBest =\n                    innerTarget.length > 0\n                        ? targetElement.spatialNavigationSearch(dir, {\n                              candidates: innerTarget,\n                              container: bestTarget,\n                          })\n                        : null;\n                if (descendantsBest) {\n                    bestTarget = descendantsBest;\n                } else if (!isFocusable(bestTarget)) {\n                    // if there is no target inside bestTarget and delegable container is not focusable,\n                    // then try to find another best target without curren best target.\n                    candidates.splice(candidates.indexOf(bestTarget), 1);\n                    bestTarget = candidates.length\n                        ? targetElement.spatialNavigationSearch(dir, {\n                              candidates: candidates,\n                              container: container,\n                          })\n                        : null;\n                }\n            }\n            return bestTarget;\n        }\n\n        return null;\n    }\n\n    /**\n     * Get the filtered candidate among candidates.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate}\n     * @function filteredCandidates\n     * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param container {Node} - The spatial navigation container\n     * @returns {sequence<Node>} The filtered candidates which are not the search origin and not in the given spatial navigation direction from the search origin\n     */\n    // TODO: Need to fix filtering the candidates with more clean code\n    function filteredCandidates(currentElm, candidates, dir, container) {\n        const originalContainer = currentElm.getSpatialNavigationContainer();\n        let eventTargetRect;\n\n        // If D(dir) is null, let candidates be the same as visibles\n        if (dir === undefined) return candidates;\n\n        // Offscreen handling when originalContainer is not <HTML>\n        if (originalContainer.parentElement && container !== originalContainer && !isVisible(currentElm)) {\n            eventTargetRect = getBoundingClientRect(originalContainer);\n        } else {\n            eventTargetRect = searchOriginRect || getBoundingClientRect(currentElm);\n        }\n\n        /*\n         * Else, let candidates be the subset of the elements in visibles\n         * whose principal boxs geometric center is within the closed half plane\n         * whose boundary goes through the geometric center of starting point and is perpendicular to D.\n         */\n        if ((isContainer(currentElm) || currentElm.nodeName === 'BODY') && !(currentElm.nodeName === 'INPUT')) {\n            return candidates.filter((candidate) => {\n                const candidateRect = getBoundingClientRect(candidate);\n                return (\n                    container.contains(candidate) &&\n                    ((currentElm.contains(candidate) &&\n                        isInside(eventTargetRect, candidateRect) &&\n                        candidate !== currentElm) ||\n                        isOutside(candidateRect, eventTargetRect, dir))\n                );\n            });\n        } else {\n            return candidates.filter((candidate) => {\n                const candidateRect = getBoundingClientRect(candidate);\n                const candidateBody = candidate.nodeName === 'IFRAME' ? candidate.contentDocument.body : null;\n                return (\n                    container.contains(candidate) &&\n                    candidate !== currentElm &&\n                    candidateBody !== currentElm &&\n                    isOutside(candidateRect, eventTargetRect, dir) &&\n                    !isInside(eventTargetRect, candidateRect)\n                );\n            });\n        }\n    }\n\n    /**\n     * Select the best candidate among given candidates.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate}\n     * @function selectBestCandidate\n     * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Node} The best candidate which will gain the focus\n     */\n    function selectBestCandidate(currentElm, candidates, dir) {\n        const container = currentElm.getSpatialNavigationContainer();\n        const spatialNavigationFunction = getComputedStyle(container).getPropertyValue('--spatial-navigation-function');\n        const currentTargetRect = searchOriginRect || getBoundingClientRect(currentElm);\n        let distanceFunction;\n        let alignedCandidates;\n\n        switch (spatialNavigationFunction) {\n            case 'grid':\n                alignedCandidates = candidates.filter((elm) =>\n                    isAligned(currentTargetRect, getBoundingClientRect(elm), dir),\n                );\n                if (alignedCandidates.length > 0) {\n                    candidates = alignedCandidates;\n                }\n                distanceFunction = getAbsoluteDistance;\n                break;\n            default:\n                distanceFunction = getDistance;\n                break;\n        }\n        return getClosestElement(currentElm, candidates, dir, distanceFunction);\n    }\n\n    /**\n     * Select the best candidate among candidates by finding the closet candidate from the edge of the currently focused element (search origin).\n     * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate (Step 5)}\n     * @function selectBestCandidateFromEdge\n     * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Node} The best candidate which will gain the focus\n     */\n    function selectBestCandidateFromEdge(currentElm, candidates, dir) {\n        if (startingPoint) return getClosestElement(currentElm, candidates, dir, getDistanceFromPoint);\n        else return getClosestElement(currentElm, candidates, dir, getInnerDistance);\n    }\n\n    /**\n     * Select the closest candidate from the currently focused element (search origin) among candidates by using the distance function.\n     * @function getClosestElement\n     * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param distanceFunction {function} - The distance function which measures the distance from the search origin to each candidate\n     * @returns {Node} The candidate which is the closest one from the search origin\n     */\n    function getClosestElement(currentElm, candidates, dir, distanceFunction) {\n        let eventTargetRect = null;\n        if (\n            window.location !== window.parent.location &&\n            (currentElm.nodeName === 'BODY' || currentElm.nodeName === 'HTML')\n        ) {\n            // If the eventTarget is iframe, then get rect of it based on its containing document\n            // Set the iframe's position as (0,0) because the rects of elements inside the iframe don't know the real iframe's position.\n            eventTargetRect = window.frameElement.getBoundingClientRect();\n            eventTargetRect.x = 0;\n            eventTargetRect.y = 0;\n        } else {\n            eventTargetRect = searchOriginRect || currentElm.getBoundingClientRect();\n        }\n\n        let minDistance = Number.POSITIVE_INFINITY;\n        let minDistanceElements = [];\n\n        if (candidates) {\n            for (let i = 0; i < candidates.length; i++) {\n                const distance = distanceFunction(eventTargetRect, getBoundingClientRect(candidates[i]), dir);\n\n                // If the same distance, the candidate will be selected in the DOM order\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    minDistanceElements = [candidates[i]];\n                } else if (distance === minDistance) {\n                    minDistanceElements.push(candidates[i]);\n                }\n            }\n        }\n        if (minDistanceElements.length === 0) return null;\n\n        return minDistanceElements.length > 1 && distanceFunction === getAbsoluteDistance\n            ? getClosestElement(currentElm, minDistanceElements, dir, getEuclideanDistance)\n            : minDistanceElements[0];\n    }\n\n    /**\n     * Get container of an element.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-getspatialnavigationcontainer}\n     * @module Element\n     * @function getSpatialNavigationContainer\n     * @returns {Node} The spatial navigation container\n     */\n    function getSpatialNavigationContainer() {\n        let container = this;\n\n        do {\n            if (!container.parentElement) {\n                if (window.location !== window.parent.location) {\n                    container = window.parent.document.documentElement;\n                } else {\n                    container = window.document.documentElement;\n                }\n                break;\n            } else {\n                container = container.parentElement;\n            }\n\n        } while (!isContainer(container));\n        return container;\n    }\n\n    /**\n     * Get nearest scroll container of an element.\n     * @function getScrollContainer\n     * @param Element\n     * @returns {Node} The spatial navigation container\n     */\n    function getScrollContainer(element) {\n        let scrollContainer = element;\n\n        do {\n            if (!scrollContainer.parentElement) {\n                if (window.location !== window.parent.location) {\n                    scrollContainer = window.parent.document.documentElement;\n                } else {\n                    scrollContainer = window.document.documentElement;\n                }\n                break;\n            } else {\n                scrollContainer = scrollContainer.parentElement;\n            }\n        } while (!isScrollContainer(scrollContainer) || !isVisible(scrollContainer));\n\n        if (scrollContainer === document || scrollContainer === document.documentElement) {\n            scrollContainer = window;\n        }\n\n        return scrollContainer;\n    }\n\n    /**\n     * Find focusable elements within the spatial navigation container.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-focusableareas}\n     * @function focusableAreas\n     * @param option {FocusableAreasOptions} - 'mode' attribute takes 'visible' or 'all' for searching the boundary of focusable elements.\n     *                                          Default value is 'visible'.\n     * @returns {sequence<Node>} All focusable elements or only visible focusable elements within the container\n     */\n    function focusableAreas(option = { mode: 'visible' }) {\n        const container = this.parentElement ? this : document.body;\n        const focusables = Array.prototype.filter.call(container.getElementsByTagName('*'), isFocusable);\n        return option.mode === 'all' ? focusables : focusables.filter(isVisible);\n    }\n\n    /**\n     * Create the NavigationEvent: navbeforefocus, navnotarget\n     * @see {@link https://drafts.csswg.org/css-nav-1/#events-navigationevent}\n     * @function createSpatNavEvents\n     * @param option {string} - Type of the navigation event (beforefocus, notarget)\n     * @param element {Node} - The target element of the event\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     */\n    function createSpatNavEvents(eventType, containerElement, currentElement, direction) {\n        if (['beforefocus', 'notarget'].includes(eventType)) {\n            const data = {\n                causedTarget: currentElement,\n                dir: direction,\n            };\n            const triggeredEvent = new CustomEvent('nav' + eventType, {\n                bubbles: true,\n                cancelable: true,\n                detail: data,\n            });\n            return containerElement.dispatchEvent(triggeredEvent);\n        }\n    }\n\n    /**\n     * Get the value of the CSS custom property of the element\n     * @function readCssVar\n     * @param element {Node}\n     * @param varName {string} - The name of the css custom property without '--'\n     * @returns {string} The value of the css custom property\n     */\n    function readCssVar(element, varName) {\n        return getComputedStyle(element).getPropertyValue(`--${varName}`).trim();\n    }\n\n    /**\n     * Decide whether or not the 'contain' value is given to 'spatial-navigation-contain' css property of an element\n     * @function isCSSSpatNavContain\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isCSSSpatNavContain(element) {\n        return readCssVar(element, 'spatial-navigation-contain') === 'contain';\n    }\n\n    /**\n     * Return the value of 'spatial-navigation-action' css property of an element\n     * @function getCSSSpatNavAction\n     * @param element {Node} - would be the spatial navigation container\n     * @returns {string} auto | focus | scroll\n     */\n    function getCSSSpatNavAction(element) {\n        return 'focus';\n        //   return readCssVar(element, 'spatial-navigation-action') || 'auto';\n    }\n\n    /**\n     * Only move the focus with spatial navigation. Manually scrolling isn't available.\n     * @function navigateChain\n     * @param eventTarget {Node} - currently focused element\n     * @param container {SpatialNavigationContainer} - container\n     * @param parentContainer {SpatialNavigationContainer} - parent container\n     * @param option - visible || all\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     */\n    function navigateChain(eventTarget, container, parentContainer, dir, option) {\n        let currentOption = {\n            candidates: getSpatialNavigationCandidates(container, { mode: option }),\n            container,\n        };\n\n        while (parentContainer) {\n            if (focusingController(eventTarget.spatialNavigationSearch(dir, currentOption), dir)) {\n                return;\n            } else {\n                if (option === 'visible' && scrollingController(container, dir)) return;\n                else {\n                    if (!createSpatNavEvents('notarget', container, eventTarget, dir)) return;\n\n                    // find the container\n                    if (container === document || container === document.documentElement) {\n                        if (window.location !== window.parent.location) {\n                            // The page is in an iframe. eventTarget needs to be reset because the position of the element in the iframe\n                            eventTarget = window.frameElement;\n                            container = eventTarget.ownerDocument.documentElement;\n                        }\n                    } else {\n                        container = parentContainer;\n                    }\n                    currentOption = {\n                        candidates: getSpatialNavigationCandidates(container, {\n                            mode: option,\n                        }),\n                        container,\n                    };\n                    let nextContainer = container.getSpatialNavigationContainer();\n\n                    if (nextContainer !== container) {\n                        parentContainer = nextContainer;\n                    } else {\n                        parentContainer = null;\n                    }\n                }\n            }\n        }\n\n        currentOption = {\n            candidates: getSpatialNavigationCandidates(container, { mode: option }),\n            container,\n        };\n\n        // Behavior after 'navnotarget' - Getting out from the current spatnav container\n        if (\n            !parentContainer &&\n            container &&\n            focusingController(eventTarget.spatialNavigationSearch(dir, currentOption), dir)\n        )\n            return;\n\n        if (!createSpatNavEvents('notarget', currentOption.container, eventTarget, dir)) return;\n\n        if (getCSSSpatNavAction(container) === 'auto' && option === 'visible') {\n            if (scrollingController(container, dir)) return;\n        }\n    }\n\n    /**\n     * Find search origin\n     * @see {@link https://drafts.csswg.org/css-nav-1/#nav}\n     * @function findSearchOrigin\n     * @returns {Node} The search origin for the spatial navigation\n     */\n    function findSearchOrigin() {\n        let searchOrigin = document.activeElement;\n\n        if (!searchOrigin || (searchOrigin === document.body && !document.querySelector(':focus'))) {\n            // When the previous search origin lost its focus by blur: (1) disable attribute (2) visibility: hidden\n            if (savedSearchOrigin.element && searchOrigin !== savedSearchOrigin.element) {\n                const elementStyle = window.getComputedStyle(savedSearchOrigin.element, null);\n                const invisibleStyle = ['hidden', 'collapse'];\n\n                if (\n                    savedSearchOrigin.element.disabled ||\n                    invisibleStyle.includes(elementStyle.getPropertyValue('visibility'))\n                ) {\n                    searchOrigin = savedSearchOrigin.element;\n                    return searchOrigin;\n                }\n            }\n            searchOrigin = document.documentElement;\n        }\n        // When the previous search origin lost its focus by blur: (1) display:none () element size turned into zero\n        if (\n            savedSearchOrigin.element &&\n            (getBoundingClientRect(savedSearchOrigin.element).height === 0 ||\n                getBoundingClientRect(savedSearchOrigin.element).width === 0)\n        ) {\n            (startingPoint = (savedSearchOrigin.left + savedSearchOrigin.right) / 2),\n                (savedSearchOrigin.top + savedSearchOrigin.bottom) / 2;\n            // searchOriginRect = savedSearchOrigin.rect;\n        }\n\n        if (!isVisibleInScroller(searchOrigin)) {\n            const scroller = getScrollContainer(searchOrigin);\n            if (scroller && (scroller === window || getCSSSpatNavAction(scroller) === 'auto')) return scroller;\n        }\n        return searchOrigin;\n    }\n\n    /**\n     * Move the scroll of an element depending on the given spatial navigation directrion\n     * (Assume that User Agent defined distance is '40px')\n     * @see {@link https://drafts.csswg.org/css-nav-1/#directionally-scroll-an-element}\n     * @function moveScroll\n     * @param element {Node} - The scrollable element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param offset {Number} - The explicit amount of offset for scrolling. Default value is 0.\n     */\n    function moveScroll(element, dir, offset = 0) {\n        if (element) {\n            switch (dir) {\n                case 'left':\n                    element.scrollLeft -= 40 + offset;\n                    break;\n                case 'right':\n                    element.scrollLeft += 40 + offset;\n                    break;\n                case 'up':\n                    element.scrollTop -= 40 + offset;\n                    break;\n                case 'down':\n                    element.scrollTop += 40 + offset;\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Decide whether an element is container or not.\n     * @function isContainer\n     * @param element {Node} element\n     * @returns {boolean}\n     */\n    function isContainer(element) {\n        return (\n            !element.parentElement ||\n            element.nodeName === 'IFRAME' ||\n            isScrollContainer(element) ||\n            isCSSSpatNavContain(element)\n        );\n    }\n\n    /**\n     * Decide whether an element is delegable container or not.\n     * NOTE: THIS IS NON-NORMATIVE API.\n     * @function isDelegableContainer\n     * @param element {Node} element\n     * @returns {boolean}\n     */\n    function isDelegableContainer(element) {\n        return readCssVar(element, 'spatial-navigation-contain') === 'delegable';\n    }\n\n    /**\n     * Decide whether an element is a scrollable container or not.\n     * @see {@link https://drafts.csswg.org/css-overflow-3/#scroll-container}\n     * @function isScrollContainer\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isScrollContainer(element) {\n        const elementStyle = window.getComputedStyle(element, null);\n        const overflowX = elementStyle.getPropertyValue('overflow-x');\n        const overflowY = elementStyle.getPropertyValue('overflow-y');\n\n        return (overflowX !== 'visible' && overflowX !== 'clip' && isOverflow(element, 'left')) ||\n            (overflowY !== 'visible' && overflowY !== 'clip' && isOverflow(element, 'down'))\n            ? true\n            : false;\n    }\n\n    /**\n     * Decide whether this element is scrollable or not.\n     * NOTE: If the value of 'overflow' is given to either 'visible', 'clip', or 'hidden', the element isn't scrollable.\n     *       If the value is 'hidden', the element can be only programmically scrollable. (https://drafts.csswg.org/css-overflow-3/#valdef-overflow-hidden)\n     * @function isScrollable\n     * @param element {Node}\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isScrollable(element, dir) {\n        // element, dir\n        if (element && typeof element === 'object') {\n            if (dir && typeof dir === 'string') {\n                // parameter: dir, element\n                if (isOverflow(element, dir)) {\n                    // style property\n                    const elementStyle = window.getComputedStyle(element, null);\n                    const overflowX = elementStyle.getPropertyValue('overflow-x');\n                    const overflowY = elementStyle.getPropertyValue('overflow-y');\n\n                    switch (dir) {\n                        case 'left':\n                        /* falls through */\n                        case 'right':\n                            return overflowX !== 'visible' && overflowX !== 'clip' && overflowX !== 'hidden';\n                        case 'up':\n                        /* falls through */\n                        case 'down':\n                            return overflowY !== 'visible' && overflowY !== 'clip' && overflowY !== 'hidden';\n                    }\n                }\n                return false;\n            } else {\n                // parameter: element\n                return (\n                    element.nodeName === 'HTML' ||\n                    element.nodeName === 'BODY' ||\n                    (isScrollContainer(element) && isOverflow(element))\n                );\n            }\n        }\n    }\n\n    /**\n     * Decide whether an element is overflow or not.\n     * @function isOverflow\n     * @param element {Node}\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isOverflow(element, dir) {\n        if (element && typeof element === 'object') {\n            if (dir && typeof dir === 'string') {\n                // parameter: element, dir\n                switch (dir) {\n                    case 'left':\n                    /* falls through */\n                    case 'right':\n                        return element.scrollWidth > element.clientWidth;\n                    case 'up':\n                    /* falls through */\n                    case 'down':\n                        return element.scrollHeight > element.clientHeight;\n                }\n            } else {\n                // parameter: element\n                return element.scrollWidth > element.clientWidth || element.scrollHeight > element.clientHeight;\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Decide whether the scrollbar of the browsing context reaches to the end or not.\n     * @function isHTMLScrollBoundary\n     * @param element {Node} - The top browsing context\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isHTMLScrollBoundary(element, dir) {\n        let result = false;\n        switch (dir) {\n            case 'left':\n                result = element.scrollLeft === 0;\n                break;\n            case 'right':\n                result = element.scrollWidth - element.scrollLeft - element.clientWidth === 0;\n                break;\n            case 'up':\n                result = element.scrollTop === 0;\n                break;\n            case 'down':\n                result = element.scrollHeight - element.scrollTop - element.clientHeight === 0;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Decide whether the scrollbar of an element reaches to the end or not.\n     * @function isScrollBoundary\n     * @param element {Node}\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isScrollBoundary(element, dir) {\n        if (isScrollable(element, dir)) {\n            const winScrollY = element.scrollTop;\n            const winScrollX = element.scrollLeft;\n\n            const height = element.scrollHeight - element.clientHeight;\n            const width = element.scrollWidth - element.clientWidth;\n\n            switch (dir) {\n                case 'left':\n                    return winScrollX === 0;\n                case 'right':\n                    return Math.abs(winScrollX - width) <= 1;\n                case 'up':\n                    return winScrollY === 0;\n                case 'down':\n                    return Math.abs(winScrollY - height) <= 1;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Decide whether an element is inside the scorller viewport or not\n     *\n     * @function isVisibleInScroller\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isVisibleInScroller(element) {\n        const elementRect = element.getBoundingClientRect();\n        let nearestScroller = getScrollContainer(element);\n\n        let scrollerRect = null;\n        if (nearestScroller !== window) {\n            scrollerRect = getBoundingClientRect(nearestScroller);\n        } else {\n            scrollerRect = new DOMRect(0, 0, window.innerWidth, window.innerHeight);\n        }\n\n        if (isInside(scrollerRect, elementRect, 'left') && isInside(scrollerRect, elementRect, 'down')) return true;\n        else return false;\n    }\n\n    /**\n     * Decide whether an element is focusable for spatial navigation.\n     * 1. If element is the browsing context (document, iframe), then it's focusable,\n     * 2. If the element is scrollable container (regardless of scrollable axis), then it's focusable,\n     * 3. The value of tabIndex >= 0, then it's focusable,\n     * 4. If the element is disabled, it isn't focusable,\n     * 5. If the element is expressly inert, it isn't focusable,\n     * 6. Whether the element is being rendered or not.\n     *\n     * @function isFocusable\n     * @param element {Node}\n     * @returns {boolean}\n     *\n     * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#focusable-area}\n     */\n    function isFocusable(element) {\n        if (\n            element.tabIndex < 0 ||\n            isAtagWithoutHref(element) ||\n            isActuallyDisabled(element) ||\n            isExpresslyInert(element) ||\n            !isBeingRendered(element)\n        )\n            return false;\n        else if (!element.parentElement || (isScrollable(element) && isOverflow(element)) || element.tabIndex >= 0)\n            return true;\n    }\n\n    /**\n     * Decide whether an element is a tag without href attribute or not.\n     *\n     * @function isAtagWithoutHref\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isAtagWithoutHref(element) {\n        return (\n            element.tagName === 'A' &&\n            element.getAttribute('href') === null &&\n            element.getAttribute('tabIndex') === null\n        );\n    }\n\n    /**\n     * Decide whether an element is actually disabled or not.\n     *\n     * @function isActuallyDisabled\n     * @param element {Node}\n     * @returns {boolean}\n     *\n     * @see {@link https://html.spec.whatwg.org/multipage/semantics-other.html#concept-element-disabled}\n     */\n    function isActuallyDisabled(element) {\n        if (['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTGROUP', 'OPTION', 'FIELDSET'].includes(element.tagName))\n            return element.disabled;\n        else return false;\n    }\n\n    /**\n     * Decide whether the element is expressly inert or not.\n     * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#expressly-inert}\n     * @function isExpresslyInert\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isExpresslyInert(element) {\n        return element.inert && !element.ownerDocument.documentElement.inert;\n    }\n\n    /**\n     * Decide whether the element is being rendered or not.\n     * 1. If an element has the style as \"visibility: hidden | collapse\" or \"display: none\", it is not being rendered.\n     * 2. If an element has the style as \"opacity: 0\", it is not being rendered.(that is, invisible).\n     * 3. If width and height of an element are explicitly set to 0, it is not being rendered.\n     * 4. If a parent element is hidden, an element itself is not being rendered.\n     * (CSS visibility property and display property are inherited.)\n     * @see {@link https://html.spec.whatwg.org/multipage/rendering.html#being-rendered}\n     * @function isBeingRendered\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isBeingRendered(element) {\n        if (!isVisibleStyleProperty(element.parentElement)) return false;\n        if (\n            !isVisibleStyleProperty(element) ||\n            element.style.opacity === '0' ||\n            window.getComputedStyle(element).height === '0px' ||\n            window.getComputedStyle(element).width === '0px'\n        )\n            return false;\n        return true;\n    }\n\n    /**\n     * Decide whether this element is partially or completely visible to user agent.\n     * @function isVisible\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isVisible(element) {\n        return !element.parentElement || (isVisibleStyleProperty(element) && hitTest(element));\n    }\n\n    /**\n     * Decide whether this element is completely visible in this viewport for the arrow direction.\n     * @function isEntirelyVisible\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isEntirelyVisible(element, container) {\n        const rect = getBoundingClientRect(element);\n        const containerElm = container || element.getSpatialNavigationContainer();\n        const containerRect = getBoundingClientRect(containerElm);\n\n        // FIXME: when element is bigger than container?\n        const entirelyVisible = !(\n            rect.left < containerRect.left ||\n            rect.right > containerRect.right ||\n            rect.top < containerRect.top ||\n            rect.bottom > containerRect.bottom\n        );\n\n        return entirelyVisible;\n    }\n\n    /**\n     * Decide the style property of this element is specified whether it's visible or not.\n     * @function isVisibleStyleProperty\n     * @param element {CSSStyleDeclaration}\n     * @returns {boolean}\n     */\n    function isVisibleStyleProperty(element) {\n        const elementStyle = window.getComputedStyle(element, null);\n        const thisVisibility = elementStyle.getPropertyValue('visibility');\n        const thisDisplay = elementStyle.getPropertyValue('display');\n        const invisibleStyle = ['hidden', 'collapse'];\n\n        return thisDisplay !== 'none' && !invisibleStyle.includes(thisVisibility);\n    }\n\n    /**\n     * Decide whether this element is entirely or partially visible within the viewport.\n     * @function hitTest\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function hitTest(element) {\n        const elementRect = getBoundingClientRect(element);\n        if (\n            element.nodeName !== 'IFRAME' &&\n            (elementRect.top < 0 ||\n                elementRect.left < 0 ||\n                elementRect.top > element.ownerDocument.documentElement.clientHeight ||\n                elementRect.left > element.ownerDocument.documentElement.clientWidth)\n        )\n            return false;\n\n        let offsetX = parseInt(element.offsetWidth) / 10;\n        let offsetY = parseInt(element.offsetHeight) / 10;\n\n        offsetX = isNaN(offsetX) ? 1 : offsetX;\n        offsetY = isNaN(offsetY) ? 1 : offsetY;\n\n        const hitTestPoint = {\n            // For performance, just using the three point(middle, leftTop, rightBottom) of the element for hit testing\n            middle: [(elementRect.left + elementRect.right) / 2, (elementRect.top + elementRect.bottom) / 2],\n            leftTop: [elementRect.left + offsetX, elementRect.top + offsetY],\n            rightBottom: [elementRect.right - offsetX, elementRect.bottom - offsetY],\n        };\n\n        for (const point in hitTestPoint) {\n            const elemFromPoint = element.ownerDocument.elementFromPoint(...hitTestPoint[point]);\n            if (element === elemFromPoint || element.contains(elemFromPoint)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Decide whether a child element is entirely or partially Included within container visually.\n     * @function isInside\n     * @param containerRect {DOMRect}\n     * @param childRect {DOMRect}\n     * @returns {boolean}\n     */\n    function isInside(containerRect, childRect) {\n        const rightEdgeCheck = containerRect.left < childRect.right && containerRect.right >= childRect.right;\n        const leftEdgeCheck = containerRect.left <= childRect.left && containerRect.right > childRect.left;\n        const topEdgeCheck = containerRect.top <= childRect.top && containerRect.bottom > childRect.top;\n        const bottomEdgeCheck = containerRect.top < childRect.bottom && containerRect.bottom >= childRect.bottom;\n        return (rightEdgeCheck || leftEdgeCheck) && (topEdgeCheck || bottomEdgeCheck);\n    }\n\n    /**\n     * Decide whether this element is entirely or partially visible within the viewport.\n     * Note: rect1 is outside of rect2 for the dir\n     * @function isOutside\n     * @param rect1 {DOMRect}\n     * @param rect2 {DOMRect}\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isOutside(rect1, rect2, dir) {\n        switch (dir) {\n            case 'left':\n                return isRightSide(rect2, rect1);\n            case 'right':\n                return isRightSide(rect1, rect2);\n            case 'up':\n                return isBelow(rect2, rect1);\n            case 'down':\n                return isBelow(rect1, rect2);\n            default:\n                return false;\n        }\n    }\n\n    /* rect1 is right of rect2 */\n    function isRightSide(rect1, rect2) {\n        return (\n            rect1.left >= rect2.right ||\n            (rect1.left >= rect2.left &&\n                rect1.right > rect2.right &&\n                rect1.bottom > rect2.top &&\n                rect1.top < rect2.bottom)\n        );\n    }\n\n    /* rect1 is below of rect2 */\n    function isBelow(rect1, rect2) {\n        return (\n            rect1.top >= rect2.bottom ||\n            (rect1.top >= rect2.top &&\n                rect1.bottom > rect2.bottom &&\n                rect1.left < rect2.right &&\n                rect1.right > rect2.left)\n        );\n    }\n\n    /* rect1 is completely aligned or partially aligned for the direction */\n    function isAligned(rect1, rect2, dir) {\n        switch (dir) {\n            case 'left':\n            /* falls through */\n            case 'right':\n                return rect1.bottom > rect2.top && rect1.top < rect2.bottom;\n            case 'up':\n            /* falls through */\n            case 'down':\n                return rect1.right > rect2.left && rect1.left < rect2.right;\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * Get distance between the search origin and a candidate element along the direction when candidate element is inside the search origin.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}\n     * @function getDistanceFromPoint\n     * @param point {Point} - The search origin\n     * @param element {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The euclidian distance between the spatial navigation container and an element inside it\n     */\n    function getDistanceFromPoint(point, element, dir) {\n        point = startingPoint;\n        // Get exit point, entry point -> {x: '', y: ''};\n        const points = getEntryAndExitPoints(dir, point, element);\n\n        // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate\n        // that minimize the distance between these two points\n        const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);\n        const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);\n\n        // The result is euclidian distance between P1 and P2.\n        return Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));\n    }\n\n    /**\n     * Get distance between the search origin and a candidate element along the direction when candidate element is inside the search origin.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}\n     * @function getInnerDistance\n     * @param rect1 {DOMRect} - The search origin\n     * @param rect2 {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The euclidean distance between the spatial navigation container and an element inside it\n     */\n    function getInnerDistance(rect1, rect2, dir) {\n        const baseEdgeForEachDirection = {\n            left: 'right',\n            right: 'left',\n            up: 'bottom',\n            down: 'top',\n        };\n        const baseEdge = baseEdgeForEachDirection[dir];\n\n        return Math.abs(rect1[baseEdge] - rect2[baseEdge]);\n    }\n\n    /**\n     * Get the distance between the search origin and a candidate element considering the direction.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#calculating-the-distance}\n     * @function getDistance\n     * @param searchOrigin {DOMRect | Point} - The search origin\n     * @param candidateRect {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The distance scoring between two elements\n     */\n    function getDistance(searchOrigin, candidateRect, dir) {\n        const kOrthogonalWeightForLeftRight = 30;\n        const kOrthogonalWeightForUpDown = 2;\n\n        let orthogonalBias = 0;\n        let alignBias = 0;\n        const alignWeight = 5.0;\n\n        // Get exit point, entry point -> {x: '', y: ''};\n        const points = getEntryAndExitPoints(dir, searchOrigin, candidateRect);\n\n        // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate\n        // that minimize the distance between these two points\n        const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);\n        const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);\n\n        // A: The euclidean distance between P1 and P2.\n        const A = Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));\n        let B, C;\n\n        // B: The absolute distance in the direction which is orthogonal to dir between P1 and P2, or 0 if dir is null.\n        // C: The intersection edges between a candidate and the starting point.\n\n        // D: The square root of the area of intersection between the border boxes of candidate and starting point\n        const intersectionRect = getIntersectionRect(searchOrigin, candidateRect);\n        const D = intersectionRect.area;\n\n        switch (dir) {\n            case 'left':\n            /* falls through */\n            case 'right':\n                // If two elements are aligned, add align bias\n                // else, add orthogonal bias\n                if (isAligned(searchOrigin, candidateRect, dir))\n                    alignBias = Math.min(intersectionRect.height / searchOrigin.height, 1);\n                else orthogonalBias = searchOrigin.height / 2;\n\n                B = (P2 + orthogonalBias) * kOrthogonalWeightForLeftRight;\n                C = alignWeight * alignBias;\n                break;\n\n            case 'up':\n            /* falls through */\n            case 'down':\n                // If two elements are aligned, add align bias\n                // else, add orthogonal bias\n                if (isAligned(searchOrigin, candidateRect, dir))\n                    alignBias = Math.min(intersectionRect.width / searchOrigin.width, 1);\n                else orthogonalBias = searchOrigin.width / 2;\n\n                B = (P1 + orthogonalBias) * kOrthogonalWeightForUpDown;\n                C = alignWeight * alignBias;\n                break;\n\n            default:\n                B = 0;\n                C = 0;\n                break;\n        }\n\n        return A + B - C - D;\n    }\n\n    /**\n     * Get the euclidean distance between the search origin and a candidate element considering the direction.\n     * @function getEuclideanDistance\n     * @param rect1 {DOMRect} - The search origin\n     * @param rect2 {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The distance scoring between two elements\n     */\n    function getEuclideanDistance(rect1, rect2, dir) {\n        // Get exit point, entry point\n        const points = getEntryAndExitPoints(dir, rect1, rect2);\n\n        // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate\n        // that minimize the distance between these two points\n        const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);\n        const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);\n\n        // Return the euclidean distance between P1 and P2.\n        return Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));\n    }\n\n    /**\n     * Get the absolute distance between the search origin and a candidate element considering the direction.\n     * @function getAbsoluteDistance\n     * @param rect1 {DOMRect} - The search origin\n     * @param rect2 {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The distance scoring between two elements\n     */\n    function getAbsoluteDistance(rect1, rect2, dir) {\n        // Get exit point, entry point\n        const points = getEntryAndExitPoints(dir, rect1, rect2);\n\n        // Return the absolute distance in the dir direction between P1 and P.\n        return dir === 'left' || dir === 'right'\n            ? Math.abs(points.entryPoint.x - points.exitPoint.x)\n            : Math.abs(points.entryPoint.y - points.exitPoint.y);\n    }\n\n    /**\n     * Get entry point and exit point of two elements considering the direction.\n     * @function getEntryAndExitPoints\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD). Default value for dir is 'down'.\n     * @param searchOrigin {DOMRect | Point} - The search origin which contains the exit point\n     * @param candidateRect {DOMRect} - One of candidates which contains the entry point\n     * @returns {Points} The exit point from the search origin and the entry point from a candidate\n     */\n    function getEntryAndExitPoints(dir = 'down', searchOrigin, candidateRect) {\n        /**\n         * User type definition for Point\n         * @typeof {Object} Points\n         * @property {Point} Points.entryPoint\n         * @property {Point} Points.exitPoint\n         */\n        const points = { entryPoint: { x: 0, y: 0 }, exitPoint: { x: 0, y: 0 } };\n\n        if (startingPoint) {\n            points.exitPoint = searchOrigin;\n\n            switch (dir) {\n                case 'left':\n                    points.entryPoint.x = candidateRect.right;\n                    break;\n                case 'up':\n                    points.entryPoint.y = candidateRect.bottom;\n                    break;\n                case 'right':\n                    points.entryPoint.x = candidateRect.left;\n                    break;\n                case 'down':\n                    points.entryPoint.y = candidateRect.top;\n                    break;\n            }\n\n            // Set orthogonal direction\n            switch (dir) {\n                case 'left':\n                case 'right':\n                    if (startingPoint.y <= candidateRect.top) {\n                        points.entryPoint.y = candidateRect.top;\n                    } else if (startingPoint.y < candidateRect.bottom) {\n                        points.entryPoint.y = startingPoint.y;\n                    } else {\n                        points.entryPoint.y = candidateRect.bottom;\n                    }\n                    break;\n\n                case 'up':\n                case 'down':\n                    if (startingPoint.x <= candidateRect.left) {\n                        points.entryPoint.x = candidateRect.left;\n                    } else if (startingPoint.x < candidateRect.right) {\n                        points.entryPoint.x = startingPoint.x;\n                    } else {\n                        points.entryPoint.x = candidateRect.right;\n                    }\n                    break;\n            }\n        } else {\n            // Set direction\n            switch (dir) {\n                case 'left':\n                    points.exitPoint.x = searchOrigin.left;\n                    points.entryPoint.x =\n                        candidateRect.right < searchOrigin.left ? candidateRect.right : searchOrigin.left;\n                    break;\n                case 'up':\n                    points.exitPoint.y = searchOrigin.top;\n                    points.entryPoint.y =\n                        candidateRect.bottom < searchOrigin.top ? candidateRect.bottom : searchOrigin.top;\n                    break;\n                case 'right':\n                    points.exitPoint.x = searchOrigin.right;\n                    points.entryPoint.x =\n                        candidateRect.left > searchOrigin.right ? candidateRect.left : searchOrigin.right;\n                    break;\n                case 'down':\n                    points.exitPoint.y = searchOrigin.bottom;\n                    points.entryPoint.y =\n                        candidateRect.top > searchOrigin.bottom ? candidateRect.top : searchOrigin.bottom;\n                    break;\n            }\n\n            // Set orthogonal direction\n            switch (dir) {\n                case 'left':\n                case 'right':\n                    if (isBelow(searchOrigin, candidateRect)) {\n                        points.exitPoint.y = searchOrigin.top;\n                        points.entryPoint.y =\n                            candidateRect.bottom < searchOrigin.top ? candidateRect.bottom : searchOrigin.top;\n                    } else if (isBelow(candidateRect, searchOrigin)) {\n                        points.exitPoint.y = searchOrigin.bottom;\n                        points.entryPoint.y =\n                            candidateRect.top > searchOrigin.bottom ? candidateRect.top : searchOrigin.bottom;\n                    } else {\n                        points.exitPoint.y = Math.max(searchOrigin.top, candidateRect.top);\n                        points.entryPoint.y = points.exitPoint.y;\n                    }\n                    break;\n\n                case 'up':\n                case 'down':\n                    if (isRightSide(searchOrigin, candidateRect)) {\n                        points.exitPoint.x = searchOrigin.left;\n                        points.entryPoint.x =\n                            candidateRect.right < searchOrigin.left ? candidateRect.right : searchOrigin.left;\n                    } else if (isRightSide(candidateRect, searchOrigin)) {\n                        points.exitPoint.x = searchOrigin.right;\n                        points.entryPoint.x =\n                            candidateRect.left > searchOrigin.right ? candidateRect.left : searchOrigin.right;\n                    } else {\n                        points.exitPoint.x = Math.max(searchOrigin.left, candidateRect.left);\n                        points.entryPoint.x = points.exitPoint.x;\n                    }\n                    break;\n            }\n        }\n\n        return points;\n    }\n\n    /**\n     * Find focusable elements within the container\n     * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}\n     * @function getIntersectionRect\n     * @param rect1 {DOMRect} - The search origin which contains the exit point\n     * @param rect2 {DOMRect} - One of candidates which contains the entry point\n     * @returns {IntersectionArea} The intersection area between two elements.\n     *\n     * @typeof {Object} IntersectionArea\n     * @property {Number} IntersectionArea.width\n     * @property {Number} IntersectionArea.height\n     */\n    function getIntersectionRect(rect1, rect2) {\n        const intersection_rect = { width: 0, height: 0, area: 0 };\n\n        const new_location = [Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)];\n        const new_max_point = [Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom)];\n\n        intersection_rect.width = Math.abs(new_location[0] - new_max_point[0]);\n        intersection_rect.height = Math.abs(new_location[1] - new_max_point[1]);\n\n        if (!(new_location[0] >= new_max_point[0] || new_location[1] >= new_max_point[1])) {\n            // intersecting-cases\n            intersection_rect.area = Math.sqrt(intersection_rect.width * intersection_rect.height);\n        }\n\n        return intersection_rect;\n    }\n\n    /**\n     * Handle the spatial navigation behavior for HTMLInputElement, HTMLTextAreaElement\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input|HTMLInputElement (MDN)}\n     * @function handlingEditableElement\n     * @param e {Event} - keydownEvent\n     * @returns {boolean}\n     */\n    function handlingEditableElement(e) {\n        const SPINNABLE_INPUT_TYPES = ['email', 'date', 'month', 'number', 'time', 'week'],\n            TEXT_INPUT_TYPES = ['password', 'text', 'search', 'tel', 'url', null];\n        const eventTarget = document.activeElement;\n        const startPosition = eventTarget.selectionStart;\n        const endPosition = eventTarget.selectionEnd;\n        const focusNavigableArrowKey = {\n            left: false,\n            up: false,\n            right: false,\n            down: false,\n        };\n\n        const dir = ARROW_KEY_CODE[e.keyCode];\n        if (dir === undefined) {\n            return focusNavigableArrowKey;\n        }\n\n        if (SPINNABLE_INPUT_TYPES.includes(eventTarget.getAttribute('type')) && (dir === 'up' || dir === 'down')) {\n            focusNavigableArrowKey[dir] = true;\n        } else if (TEXT_INPUT_TYPES.includes(eventTarget.getAttribute('type')) || eventTarget.nodeName === 'TEXTAREA') {\n            if (startPosition === endPosition) {\n                // if there isn't any selected text\n                if (startPosition === 0) {\n                    focusNavigableArrowKey.left = true;\n                    focusNavigableArrowKey.up = true;\n                }\n                if (endPosition === eventTarget.value.length) {\n                    focusNavigableArrowKey.right = true;\n                    focusNavigableArrowKey.down = true;\n                }\n            }\n        } else {\n            // HTMLDataListElement, HTMLSelectElement, HTMLOptGroup\n            focusNavigableArrowKey[dir] = true;\n        }\n\n        return focusNavigableArrowKey;\n    }\n\n    /**\n     * Get the DOMRect of an element\n     * @function getBoundingClientRect\n     * @param {Node} element\n     * @returns {DOMRect}\n     */\n    function getBoundingClientRect(element) {\n        // memoization\n        let rect = mapOfBoundRect && mapOfBoundRect.get(element);\n        if (!rect) {\n            const boundingClientRect = element.getBoundingClientRect();\n            rect = {\n                top: Number(boundingClientRect.top.toFixed(2)),\n                right: Number(boundingClientRect.right.toFixed(2)),\n                bottom: Number(boundingClientRect.bottom.toFixed(2)),\n                left: Number(boundingClientRect.left.toFixed(2)),\n                width: Number(boundingClientRect.width.toFixed(2)),\n                height: Number(boundingClientRect.height.toFixed(2)),\n            };\n            mapOfBoundRect && mapOfBoundRect.set(element, rect);\n        }\n        return rect;\n    }\n\n    /**\n     * Get the candidates which is fully inside the target element in visual\n     * @param {Node} targetElement\n     * @returns {sequence<Node>}  overlappedCandidates\n     */\n    function getOverlappedCandidates(targetElement) {\n        const container = targetElement.getSpatialNavigationContainer();\n        const candidates = container.focusableAreas();\n        const overlappedCandidates = [];\n\n        candidates.forEach((element) => {\n            if (targetElement !== element && isEntirelyVisible(element, targetElement)) {\n                overlappedCandidates.push(element);\n            }\n        });\n\n        return overlappedCandidates;\n    }\n\n    /**\n     * Get the list of the experimental APIs\n     * @function getExperimentalAPI\n     */\n    function getExperimentalAPI() {\n        function canScroll(container, dir) {\n            return (\n                (isScrollable(container, dir) && !isScrollBoundary(container, dir)) ||\n                (!container.parentElement && !isHTMLScrollBoundary(container, dir))\n            );\n        }\n\n        function findTarget(findCandidate, element, dir, option) {\n            let eventTarget = element;\n            let bestNextTarget = null;\n\n            // 4\n            if (eventTarget === document || eventTarget === document.documentElement) {\n                eventTarget = document.body || document.documentElement;\n            }\n\n            // 5\n            // At this point, spatialNavigationSearch can be applied.\n            // If startingPoint is either a scroll container or the document,\n            // find the best candidate within startingPoint\n            if ((isContainer(eventTarget) || eventTarget.nodeName === 'BODY') && !(eventTarget.nodeName === 'INPUT')) {\n                if (eventTarget.nodeName === 'IFRAME') eventTarget = eventTarget.contentDocument.body;\n\n                const candidates = getSpatialNavigationCandidates(eventTarget, option);\n\n                // 5-2\n                if (Array.isArray(candidates) && candidates.length > 0) {\n                    return findCandidate\n                        ? getFilteredSpatialNavigationCandidates(eventTarget, dir, candidates)\n                        : eventTarget.spatialNavigationSearch(dir, { candidates });\n                }\n                if (canScroll(eventTarget, dir)) {\n                    return findCandidate ? [] : eventTarget;\n                }\n            }\n\n            // 6\n            // Let container be the nearest ancestor of eventTarget\n            let container = eventTarget.getSpatialNavigationContainer();\n            let parentContainer = container.parentElement ? container.getSpatialNavigationContainer() : null;\n\n            // When the container is the viewport of a browsing context\n            if (!parentContainer && window.location !== window.parent.location) {\n                parentContainer = window.parent.document.documentElement;\n            }\n\n            // 7\n            while (parentContainer) {\n                const candidates = filteredCandidates(\n                    eventTarget,\n                    getSpatialNavigationCandidates(container, option),\n                    dir,\n                    container,\n                );\n\n                if (Array.isArray(candidates) && candidates.length > 0) {\n                    bestNextTarget = eventTarget.spatialNavigationSearch(dir, {\n                        candidates,\n                        container,\n                    });\n                    if (bestNextTarget) {\n                        return findCandidate ? candidates : bestNextTarget;\n                    }\n                }\n\n                // If there isn't any candidate and the best candidate among candidate:\n                // 1) Scroll or 2) Find candidates of the ancestor container\n                // 8 - if\n                else if (canScroll(container, dir)) {\n                    return findCandidate ? [] : eventTarget;\n                } else if (container === document || container === document.documentElement) {\n                    container = window.document.documentElement;\n\n                    // The page is in an iframe\n                    if (window.location !== window.parent.location) {\n                        // eventTarget needs to be reset because the position of the element in the IFRAME\n                        // is unuseful when the focus moves out of the iframe\n                        eventTarget = window.frameElement;\n                        container = window.parent.document.documentElement;\n                        if (container.parentElement) parentContainer = container.getSpatialNavigationContainer();\n                        else {\n                            parentContainer = null;\n                            break;\n                        }\n                    }\n                } else {\n                    // avoiding when spatnav container with tabindex=-1\n                    if (isFocusable(container)) {\n                        eventTarget = container;\n                    }\n\n                    container = parentContainer;\n                    if (container.parentElement) parentContainer = container.getSpatialNavigationContainer();\n                    else {\n                        parentContainer = null;\n                        break;\n                    }\n                }\n            }\n\n            if (!parentContainer && container) {\n                // Getting out from the current spatnav container\n                const candidates = filteredCandidates(\n                    eventTarget,\n                    getSpatialNavigationCandidates(container, option),\n                    dir,\n                    container,\n                );\n\n                // 9\n                if (Array.isArray(candidates) && candidates.length > 0) {\n                    bestNextTarget = eventTarget.spatialNavigationSearch(dir, {\n                        candidates,\n                        container,\n                    });\n                    if (bestNextTarget) {\n                        return findCandidate ? candidates : bestNextTarget;\n                    }\n                }\n            }\n\n            if (canScroll(container, dir)) {\n                bestNextTarget = eventTarget;\n                return bestNextTarget;\n            }\n        }\n\n        return {\n            isContainer,\n            isScrollContainer,\n            isVisibleInScroller,\n            findCandidates: findTarget.bind(null, true),\n            findNextTarget: findTarget.bind(null, false),\n            getDistanceFromTarget: (element, candidateElement, dir) => {\n                if ((isContainer(element) || element.nodeName === 'BODY') && !(element.nodeName === 'INPUT')) {\n                    if (getSpatialNavigationCandidates(element).includes(candidateElement)) {\n                        return getInnerDistance(\n                            getBoundingClientRect(element),\n                            getBoundingClientRect(candidateElement),\n                            dir,\n                        );\n                    }\n                }\n                return getDistance(getBoundingClientRect(element), getBoundingClientRect(candidateElement), dir);\n            },\n        };\n    }\n\n    /**\n     * Makes to use the experimental APIs.\n     * @function enableExperimentalAPIs\n     * @param option {boolean} - If it is true, the experimental APIs can be used or it cannot.\n     */\n    function enableExperimentalAPIs(option) {\n        const currentKeyMode = window.__spatialNavigation__ && window.__spatialNavigation__.keyMode;\n        window.__spatialNavigation__ =\n            option === false ? getInitialAPIs() : Object.assign(getInitialAPIs(), getExperimentalAPI());\n        window.__spatialNavigation__.keyMode = currentKeyMode;\n        Object.seal(window.__spatialNavigation__);\n    }\n\n    /**\n     * Set the environment for using the spatial navigation polyfill.\n     * @function getInitialAPIs\n     */\n    function getInitialAPIs() {\n        return {\n            enableExperimentalAPIs,\n            get keyMode() {\n                return this._keymode ? this._keymode : 'ARROW';\n            },\n            set keyMode(mode) {\n                this._keymode = ['SHIFTARROW', 'ARROW', 'NONE'].includes(mode) ? mode : 'ARROW';\n            },\n            setStartingPoint: function (x, y) {\n                startingPoint = x && y ? { x, y } : null;\n            },\n        };\n    }\n\n    initiateSpatialNavigation();\n    enableExperimentalAPIs(true);\n\n    window.addEventListener('load', () => {\n        spatialNavigationHandler();\n    });\n})();\n\nexport const setDefaultScrollTo = () => {\n    let currentSpatialNavigationContainer = null;\n\n    function isElementInViewport(el) {\n        const rect = el.getBoundingClientRect();\n        return (\n            rect.top >= 0 &&\n            rect.left >= 0 &&\n            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n            rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n        );\n    }\n\n\n    document.addEventListener('navbeforefocus', (e) => {\n        if (e.target instanceof HTMLElement) {\n            e.preventDefault();\n\n            let { target } = e;\n\n            // focus on the first element when changing spatnav container\n            const nextSpatialNavigationContainer = target.getSpatialNavigationContainer();\n\n            if (currentSpatialNavigationContainer && currentSpatialNavigationContainer !== nextSpatialNavigationContainer) {\n                if (nextSpatialNavigationContainer.__lastElementFocused) {\n                    target = nextSpatialNavigationContainer.__lastElementFocused;\n                } else {\n                    [target] = nextSpatialNavigationContainer.focusableAreas({ mode: 'all' });\n                }\n                // target.focus();\n            }\n\n            currentSpatialNavigationContainer = nextSpatialNavigationContainer;\n            currentSpatialNavigationContainer.__lastElementFocused = target;\n\n            requestAnimationFrame(async () => {\n                target.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });\n                // if (isElementInViewport(target)) {\n                //     target.focus();\n                // }\n\n                await new Promise((resolve) => {\n                    const intersectionObserver = new IntersectionObserver(\n                        ([entry]) => {\n                            if (entry.isIntersecting) {\n                                resolve();\n                            }\n                        },\n                        {\n                            threshold: 1,\n                        },\n                    );\n                    intersectionObserver.observe(target);\n                });\n\n                target.focus();\n            });\n        }\n    });\n};\n\n//   `Enter` aka ` OK`  \ndocument.addEventListener('keyup', (event) => {\n    if (event.keyCode === 13) {\n        event.preventDefault();\n        if (document.activeElement) {\n            document.activeElement.click();\n        }\n    }\n});\n","import { useEffect } from 'react';\nimport { createAssistant } from '@sberdevices/assistant-client';\nimport Router from 'next/router';\nimport { Route } from '../consts/routes';\n\nvar initialize = function initialize() {\n  var getState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n    return {};\n  };\n  return createAssistant({\n    getState: getState\n  });\n};\n\nvar processMessage = function processMessage(message) {\n  var _message$action;\n\n  var map = {\n    // eslint-disable-next-line\n    goto_catalog: Route.INDEX,\n    // eslint-disable-next-line    \n    goto_mohito: Route.MOHITO,\n    // eslint-disable-next-line\n    goto_tropical: Route.TROPICAL,\n    // eslint-disable-next-line\n    goto_orangelemonade: Route.ORANGE_LEMONADE,\n    // eslint-disable-next-line\n    goto_mintmilk: Route.MINT_MILK,\n    // eslint-disable-next-line\n    goto_iceberg: Route.ICEBERG,\n    // eslint-disable-next-line\n    goto_chokomilk: Route.CHOKOMILK,\n    // eslint-disable-next-line\n    goto_slad: Route.SLAD,\n    // eslint-disable-next-line\n    goto_champ: Route.CHAMP,\n    // eslint-disable-next-line\n    goto_ale: Route.ALE,\n    // eslint-disable-next-line\n    goto_klement: Route.KLEMENT,\n    // eslint-disable-next-line\n    goto_prostuda: Route.PROSTUDA,\n    // eslint-disable-next-line\n    goto_gogol: Route.GOGOL\n  }; // @ts-ignore\n\n  var route = map[message === null || message === void 0 ? void 0 : (_message$action = message.action) === null || _message$action === void 0 ? void 0 : _message$action.type];\n\n  if (route) {\n    var _Router$router;\n\n    (_Router$router = Router.router) === null || _Router$router === void 0 ? void 0 : _Router$router.push(route);\n  }\n};\n\nexport var useAssistant = function useAssistant() {\n  useEffect(function () {\n    var assistant = initialize();\n    assistant.on('data', processMessage);\n  }, []);\n};","import _taggedTemplateLiteral from \"C:/Users/Professional/Documents/summer-drink-main/node_modules/next/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";\nvar __jsx = React.createElement;\n\nfunction _templateObject5() {\n  var data = _taggedTemplateLiteral([\"\\n    padding-left: \", \"px;\\n\"]);\n\n  _templateObject5 = function _templateObject5() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject4() {\n  var data = _taggedTemplateLiteral([\"\\n    margin-top: 20px;\\n\"]);\n\n  _templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject3() {\n  var data = _taggedTemplateLiteral([\"\\n    width: \", \";\\n    display: \", \";\\n\"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"\\n    color: rgba(255, 255, 255, 0.56);\\n    margin-top: 8px;\\n    margin-bottom: 2px;\\n    width: \", \";\\n    display: \", \";\\n\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    margin-bottom: \", \"px;\\n\\n    height: \", \"px;\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nimport React, { useRef, useEffect } from \"react\";\nimport { Container, Row, TextBox, Col, Card, CardContent, CardBody, TextBoxBigTitle, Body1, Body3 } from '@sberdevices/plasma-ui';\nimport Link from 'next/link';\nimport styled from 'styled-components';\nimport { detectDevice, isSberPortal } from '@sberdevices/plasma-ui/utils/deviceDetection';\nimport { createSmartappDebugger, createAssistant } from \"@sberdevices/assistant-client\";\nimport { Route } from '../consts/routes';\nimport Img from './Img';\nimport MyHeader from './MyHeader';\nvar heightMap = {\n  sberPortal: 247,\n  sberBox: 336,\n  mobile: 165\n};\nvar StyledCard = styled(Card)(_templateObject(), detectDevice() === 'mobile' ? 8 : 32, heightMap[detectDevice()]);\nvar StyledBody1 = styled(Body1)(_templateObject2(), isSberPortal() ? '100px' : '100%', isSberPortal() ? 'inline-block' : 'block');\nvar StyledBody3 = styled(Body3)(_templateObject3(), isSberPortal() ? 'calc(100% - 100px)' : '100%', isSberPortal() ? 'inline-block' : 'block');\nvar MarginTop = styled.div(_templateObject4());\nvar paddingLeft = {\n  sberPortal: 12,\n  sberBox: 52,\n  mobile: 0\n};\nvar RightCol = styled(Col)(_templateObject5(), paddingLeft[detectDevice()]);\n\nvar Half = function Half(_ref) {\n  var children = _ref.children;\n  return __jsx(Col, {\n    sizeS: 4,\n    sizeM: 3,\n    sizeL: 4,\n    sizeXL: 6\n  }, children);\n};\n\nvar initializeAssistant = function initializeAssistant(getState) {\n  if (false) {\n    var _process$env$REACT_AP;\n\n    return createSmartappDebugger({\n      token: (_process$env$REACT_AP = process.env.REACT_APP_TOKEN) !== null && _process$env$REACT_AP !== void 0 ? _process$env$REACT_AP : \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxYTk3YzdmZGI2NjdhMDdlNGZlNjJmNTRlZDNhZGI3YzFlZTk2NjdiNzVlYmY3NGI2MjRjYTQzNTIxODI1MzJlNTM5YmU5MjcwMDQyNjI5OCIsImF1ZCI6IlZQUyIsImV4cCI6MTYyNTIyNzMzMCwiaWF0IjoxNjI1MTQwOTIwLCJpc3MiOiJLRVlNQVNURVIiLCJ0eXBlIjoiQmVhcmVyIiwianRpIjoiOGFmNmNiMjAtYjBmYy00MTBmLWE1MjQtYWY0MWQzMGJmMjg4Iiwic2lkIjoiMjBhMjQ0YzQtNDFlMS00ZDk2LWFkM2MtMjUzMzkxMGViNTcyIn0.pG_uaJ8_tbiMD-7A6tLkgbBM_NdlSc8JqPbkYzwOSiIl_WOWXsyHJJgYEqWVWEddV0WpaLI5PJN-BsQ5Ez7F0AzU7YoqVuuWd5me9N0pGaVKEJsVeDlltwpquJNgabRXkPs64B45OdXH8uzW1EtMUmtumlROt1RfK28FfcXdYHE_cosstzBN8cqsUOcOk5f5wt9trXj2CQB25X26lWeXDIljvckUuP3vEfyCwoF89gG4tOwnlSGP_QbGJRvcyf0fIrAFzqeqSzMn1VjunPrGz2l3XJ-M8aHNj6OgD9O9xeiJxZEsmp6mI6PxNB6rSacDrZQt9I8RYLISXYyJcsxtOii4D8ozz5eUIGeb5t-cfaNvHbEQxAzp-8ra9AEn8XXss18a2fkJxECg44wE3s7DP3nc3QKpm1mPHMTbZBkVMq94B8_Wa3llj9mVsv4OtjG2MuLg9Pewr476SB_oyjM2WqX50fYuRICRIIqmJFt0DnTmZDJBZqG9atxphx7pNO61r-r5IaR2E8KcH69onQOLGP71Wb5BMaywxReKRxDdAHalujigqMYfxRqOx_JW_-xs5QffM1rsxKfc-7r-LEjsw2_ra8F-6ysQtLjEwp3iy6YSnMQvUUg3hxjx3Uj2hM7WOQRdOcyBnQ-LuumCBGzQmM6rZrkoJF7cEJd0dd2-UrY\",\n      initPhrase: \"\\u0417\\u0430\\u043F\\u0443\\u0441\\u0442\\u0438 \\u043C\\u043E\\u0439 \\u043C\\u043E\\u0445\\u0438\\u0442\\u043E\",\n      getState: getState\n    });\n  }\n\n  return createAssistant({\n    getState: getState\n  });\n};\n\nvar Catalog = function Catalog() {\n  var _window$AssistantHost;\n\n  var assistantStateRef = useRef();\n  var assistantRef = useRef();\n  useEffect(function () {\n    assistantRef.current = initializeAssistant(function () {\n      return assistantStateRef.current;\n    });\n    assistantRef.current.on(\"data\", function (_ref2) {\n      var action = _ref2.action;\n\n      if (action) {}\n    });\n  }, []);\n  return __jsx(React.Fragment, null, __jsx(MyHeader, {\n    label: \"\\u0411\\u0435\\u0437\\u0430\\u043B\\u043A\\u043E\\u0433\\u043E\\u043B\\u044C\\u043D\\u044B\\u0435 \\u043A\\u043E\\u043A\\u0442\\u0435\\u0439\\u043B\\u0438\",\n    onBack: (_window$AssistantHost = window.AssistantHost) === null || _window$AssistantHost === void 0 ? void 0 : _window$AssistantHost.close\n  }), __jsx(Container, null, __jsx(\"div\", {\n    style: {\n      marginLeft: 'auto',\n      marginRight: 'auto'\n    }\n  }, __jsx(Row, null, __jsx(Col, {\n    sizeS: 4,\n    sizeM: 4,\n    sizeL: 8,\n    sizeXL: 8\n  }, __jsx(Row, null, __jsx(Half, null, __jsx(Link, {\n    href: Route.MOHITO\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true,\n    onChange: function onChange() {\n      var _assistantRef$current;\n\n      return (_assistantRef$current = assistantRef.current) === null || _assistantRef$current === void 0 ? void 0 : _assistantRef$current.sendData({\n        action: {\n          type: 'MOHITO'\n        }\n      });\n    }\n  }, __jsx(CardBody, null, __jsx(Img, {\n    src: detectDevice() === 'mobile' ? '/mohito.jpg' : '/mohito.jpg'\n  }), __jsx(CardContent, {\n    cover: true\n  }, __jsx(TextBox, null, __jsx(TextBoxBigTitle, null, \"\\u041C\\u043E\\u0445\\u0438\\u0442\\u043E\"))))))), __jsx(Half, null, __jsx(Link, {\n    href: Route.TROPICAL\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(CardBody, null, __jsx(Img, {\n    src: detectDevice() === 'mobile' ? '/tropical.jpeg' : '/tropical.jpeg'\n  }), __jsx(CardContent, {\n    cover: true\n  }, __jsx(TextBox, null, __jsx(TextBoxBigTitle, null, \"\\u0422\\u0440\\u043E\\u043F\\u0438\\u0447\\u0435\\u0441\\u043A\\u0438\\u0439\"))))))), __jsx(Half, null, __jsx(Link, {\n    href: Route.ORANGE_LEMONADE\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(CardBody, null, __jsx(Img, {\n    src: detectDevice() === 'mobile' ? '/orange_lemonade.jpeg' : '/orange_lemonade.jpeg'\n  }), __jsx(CardContent, {\n    cover: true\n  }, __jsx(TextBox, null, __jsx(TextBoxBigTitle, null, \"\\u0410\\u043F\\u0435\\u043B\\u044C\\u0441\\u0438\\u043D\\u043E\\u0432\\u044B\\u0439 \\u043B\\u0438\\u043C\\u043E\\u043D\\u0430\\u0434\"))))))), __jsx(Half, null, __jsx(Link, {\n    href: Route.MINT_MILK\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(CardBody, null, __jsx(Img, {\n    src: detectDevice() === 'mobile' ? '/myatnoe_moloko_1.jpeg' : '/myatnoe_moloko_1.jpeg'\n  }), __jsx(CardContent, {\n    cover: true\n  }, __jsx(TextBox, null, __jsx(TextBoxBigTitle, null, \"\\u041C\\u044F\\u0442\\u043D\\u043E\\u0435 \\u043C\\u043E\\u043B\\u043E\\u043A\\u043E\")))))))), __jsx(Row, null, __jsx(Half, null, __jsx(Link, {\n    href: Route.ICEBERG\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(CardBody, null, __jsx(Img, {\n    src: detectDevice() === 'mobile' ? '/iceverg.jpeg' : '/iceverg.jpeg'\n  }), __jsx(CardContent, {\n    cover: true\n  }, __jsx(TextBox, null, __jsx(TextBoxBigTitle, null, \"\\u0410\\u0439\\u0441\\u0431\\u0435\\u0440\\u0433 \\u0432 \\u043E\\u043A\\u0435\\u0430\\u043D\\u0435\"))))))), __jsx(Half, null, __jsx(Link, {\n    href: Route.CHOKOMILK\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(CardBody, null, __jsx(Img, {\n    src: detectDevice() === 'mobile' ? '/chokomilk.jpeg' : '/chokomilk.jpeg'\n  }), __jsx(CardContent, {\n    cover: true\n  }, __jsx(TextBox, null, __jsx(TextBoxBigTitle, null, \"\\u041C\\u043E\\u043B\\u043E\\u0447\\u043D\\u043E-\\u0448\\u043E\\u043A\\u043E\\u043B\\u0430\\u0434\\u043D\\u044B\\u0439 \\u043A\\u043E\\u043A\\u0442\\u0435\\u0439\\u043B\\u044C\"))))))), __jsx(Half, null, __jsx(Link, {\n    href: Route.SLAD\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(CardBody, null, __jsx(Img, {\n    src: detectDevice() === 'mobile' ? '/slad.png' : '/slad.png'\n  }), __jsx(CardContent, {\n    cover: true\n  }, __jsx(TextBox, null, __jsx(TextBoxBigTitle, null, \"\\u0421\\u043B\\u0430\\u0434\\u043A\\u043E\\u0435\\u0436\\u043A\\u0430\"))))))), __jsx(Half, null, __jsx(Link, {\n    href: Route.CHAMP\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(CardBody, null, __jsx(Img, {\n    src: detectDevice() === 'mobile' ? '/champ.jpeg' : '/champ.jpeg'\n  }), __jsx(CardContent, {\n    cover: true\n  }, __jsx(TextBox, null, __jsx(TextBoxBigTitle, null, \"\\u0424\\u0430\\u043B\\u044C\\u0448\\u0438\\u0432\\u043E\\u0435 \\u0448\\u0430\\u043C\\u043F\\u0430\\u043D\\u0441\\u043A\\u043E\\u0435\")))))))), __jsx(Row, null, __jsx(Half, null, __jsx(Link, {\n    href: Route.ALE\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(CardBody, null, __jsx(Img, {\n    src: detectDevice() === 'mobile' ? '/ale.jpeg' : '/ale.jpeg'\n  }), __jsx(CardContent, {\n    cover: true\n  }, __jsx(TextBox, null, __jsx(TextBoxBigTitle, null, \"\\u0418\\u043C\\u0431\\u0438\\u0440\\u043D\\u044B\\u0439 \\u044D\\u043B\\u044C\"))))))), __jsx(Half, null, __jsx(Link, {\n    href: Route.KLEMENT\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(CardBody, null, __jsx(Img, {\n    src: detectDevice() === 'mobile' ? '/klement.jpeg' : '/klement.jpeg'\n  }), __jsx(CardContent, {\n    cover: true\n  }, __jsx(TextBox, null, __jsx(TextBoxBigTitle, null, \"\\u0421\\u0435\\u043D\\u0442-\\u041A\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\"))))))), __jsx(Half, null, __jsx(Link, {\n    href: Route.PROSTUDA\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(CardBody, null, __jsx(Img, {\n    src: detectDevice() === 'mobile' ? '/prostuda.jpeg' : '/prostuda.jpeg'\n  }), __jsx(CardContent, {\n    cover: true\n  }, __jsx(TextBox, null, __jsx(TextBoxBigTitle, null, \"\\u0423\\u0434\\u0430\\u0440 \\u043F\\u043E \\u043F\\u0440\\u043E\\u0441\\u0442\\u0443\\u0434\\u0435\"))))))), __jsx(Half, null, __jsx(Link, {\n    href: Route.GOGOL\n  }, __jsx(StyledCard, {\n    outlined: true,\n    scaleOnFocus: true\n  }, __jsx(CardBody, null, __jsx(Img, {\n    src: detectDevice() === 'mobile' ? '/gogol.jpeg' : '/gogol.jpeg'\n  }), __jsx(CardContent, {\n    cover: true\n  }, __jsx(TextBox, null, __jsx(TextBoxBigTitle, null, \"\\u0413\\u043E\\u0433\\u043E\\u043B\\u044C-\\u043C\\u043E\\u0433\\u043E\\u043B\\u044C\")))))))))))));\n};\n\nexport default Catalog;","var __jsx = React.createElement;\nimport React from 'react';\nimport { isSberPortal } from '@sberdevices/plasma-ui/utils/deviceDetection';\nimport '@sberdevices/spatial-navigation';\nimport { useAssistant } from '../hooks/useAssistant';\nimport Catalog from './Catalog';\nimport Layout from './Layout';\nexport var Root = function Root() {\n  useAssistant();\n  return __jsx(Layout, {\n    noPadding: isSberPortal()\n  }, __jsx(Catalog, null));\n};\nexport default Root;","module.exports = require('./dist/client/link')\n","\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/Professional/Documents/summer-drink-main/node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _router = require(\"../next-server/lib/router/router\");\n\nvar _router2 = require(\"./router\");\n\nvar _useIntersection = require(\"./use-intersection\");\n\nvar prefetched = {};\n\nfunction prefetch(router, href, as, options) {\n  if (false || !router) return;\n  if (!(0, _router.isLocalURL)(href)) return; // Prefetch the JSON page if asked (only in the client)\n  // We need to handle a prefetch error here since we may be\n  // loading with priority which can reject but we don't\n  // want to force navigation since this is only a prefetch\n\n  router.prefetch(href, as, options).catch(function (err) {\n    if (false) {\n      // rethrow to show invalid URL errors\n      throw err;\n    }\n  });\n  var curLocale = options && typeof options.locale !== 'undefined' ? options.locale : router && router.locale; // Join on an invalid URI character\n\n  prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')] = true;\n}\n\nfunction isModifiedEvent(event) {\n  var target = event.currentTarget.target;\n  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n  event.nativeEvent && event.nativeEvent.which === 2;\n}\n\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale) {\n  var nodeName = e.currentTarget.nodeName;\n\n  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router.isLocalURL)(href))) {\n    // ignore click for browsers default behavior\n    return;\n  }\n\n  e.preventDefault(); //  avoid scroll for urls with anchor refs\n\n  if (scroll == null) {\n    scroll = as.indexOf('#') < 0;\n  } // replace state instead of push if prop is present\n\n\n  router[replace ? 'replace' : 'push'](href, as, {\n    shallow: shallow,\n    locale: locale,\n    scroll: scroll\n  });\n}\n\nfunction Link(props) {\n  if (false) {\n    var createPropError = function createPropError(args) {\n      return new Error(\"Failed prop type: The prop `\".concat(args.key, \"` expects a \").concat(args.expected, \" in `<Link>`, but got `\").concat(args.actual, \"` instead.\") + (true ? \"\\nOpen your browser's console to view the Component stack trace.\" : ''));\n    }; // TypeScript trick for type-guarding:\n\n\n    var requiredPropsGuard = {\n      href: true\n    };\n    var requiredProps = Object.keys(requiredPropsGuard);\n    requiredProps.forEach(function (key) {\n      if (key === 'href') {\n        if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {\n          throw createPropError({\n            key: key,\n            expected: '`string` or `object`',\n            actual: props[key] === null ? 'null' : typeof props[key]\n          });\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _ = key;\n      }\n    }); // TypeScript trick for type-guarding:\n\n    var optionalPropsGuard = {\n      as: true,\n      replace: true,\n      scroll: true,\n      shallow: true,\n      passHref: true,\n      prefetch: true,\n      locale: true\n    };\n    var optionalProps = Object.keys(optionalPropsGuard);\n    optionalProps.forEach(function (key) {\n      var valType = typeof props[key];\n\n      if (key === 'as') {\n        if (props[key] && valType !== 'string' && valType !== 'object') {\n          throw createPropError({\n            key: key,\n            expected: '`string` or `object`',\n            actual: valType\n          });\n        }\n      } else if (key === 'locale') {\n        if (props[key] && valType !== 'string') {\n          throw createPropError({\n            key: key,\n            expected: '`string`',\n            actual: valType\n          });\n        }\n      } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch') {\n        if (props[key] != null && valType !== 'boolean') {\n          throw createPropError({\n            key: key,\n            expected: '`boolean`',\n            actual: valType\n          });\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _ = key;\n      }\n    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n\n    var hasWarned = _react.default.useRef(false);\n\n    if (props.prefetch && !hasWarned.current) {\n      hasWarned.current = true;\n      console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated');\n    }\n  }\n\n  var p = props.prefetch !== false;\n  var router = (0, _router2.useRouter)();\n  var pathname = router && router.pathname || '/';\n\n  var _react$default$useMem = _react.default.useMemo(function () {\n    var _ref = (0, _router.resolveHref)(pathname, props.href, true),\n        _ref2 = _slicedToArray(_ref, 2),\n        resolvedHref = _ref2[0],\n        resolvedAs = _ref2[1];\n\n    return {\n      href: resolvedHref,\n      as: props.as ? (0, _router.resolveHref)(pathname, props.as) : resolvedAs || resolvedHref\n    };\n  }, [pathname, props.href, props.as]),\n      href = _react$default$useMem.href,\n      as = _react$default$useMem.as;\n\n  var children = props.children,\n      replace = props.replace,\n      shallow = props.shallow,\n      scroll = props.scroll,\n      locale = props.locale; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag\n\n  if (typeof children === 'string') {\n    children = /*#__PURE__*/_react.default.createElement(\"a\", null, children);\n  } // This will return the first child, if multiple are provided it will throw an error\n\n\n  var child = _react.Children.only(children);\n\n  var childRef = child && typeof child === 'object' && child.ref;\n\n  var _ref3 = (0, _useIntersection.useIntersection)({\n    rootMargin: '200px'\n  }),\n      _ref4 = _slicedToArray(_ref3, 2),\n      setIntersectionRef = _ref4[0],\n      isVisible = _ref4[1];\n\n  var setRef = _react.default.useCallback(function (el) {\n    setIntersectionRef(el);\n\n    if (childRef) {\n      if (typeof childRef === 'function') childRef(el);else if (typeof childRef === 'object') {\n        childRef.current = el;\n      }\n    }\n  }, [childRef, setIntersectionRef]);\n\n  (0, _react.useEffect)(function () {\n    var shouldPrefetch = isVisible && p && (0, _router.isLocalURL)(href);\n    var curLocale = typeof locale !== 'undefined' ? locale : router && router.locale;\n    var isPrefetched = prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')];\n\n    if (shouldPrefetch && !isPrefetched) {\n      prefetch(router, href, as, {\n        locale: curLocale\n      });\n    }\n  }, [as, href, isVisible, locale, p, router]);\n  var childProps = {\n    ref: setRef,\n    onClick: function onClick(e) {\n      if (child.props && typeof child.props.onClick === 'function') {\n        child.props.onClick(e);\n      }\n\n      if (!e.defaultPrevented) {\n        linkClicked(e, router, href, as, replace, shallow, scroll, locale);\n      }\n    }\n  };\n\n  childProps.onMouseEnter = function (e) {\n    if (!(0, _router.isLocalURL)(href)) return;\n\n    if (child.props && typeof child.props.onMouseEnter === 'function') {\n      child.props.onMouseEnter(e);\n    }\n\n    prefetch(router, href, as, {\n      priority: true\n    });\n  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n  // defined, we specify the current 'href', so that repetition is not needed by the user\n\n\n  if (props.passHref || child.type === 'a' && !('href' in child.props)) {\n    var curLocale = typeof locale !== 'undefined' ? locale : router && router.locale; // we only render domain locales if we are currently on a domain locale\n    // so that locale links are still visitable in development/preview envs\n\n    var localeDomain = router && router.isLocaleDomain && (0, _router.getDomainLocale)(as, curLocale, router && router.locales, router && router.domainLocales);\n    childProps.href = localeDomain || (0, _router.addBasePath)((0, _router.addLocale)(as, curLocale, router && router.defaultLocale));\n  }\n\n  return /*#__PURE__*/_react.default.cloneElement(child, childProps);\n}\n\nvar _default = Link;\nexports.default = _default;","import _extends from \"C:/Users/Professional/Documents/summer-drink-main/node_modules/next/node_modules/@babel/runtime/helpers/esm/extends\";\nimport _taggedTemplateLiteral from \"C:/Users/Professional/Documents/summer-drink-main/node_modules/next/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";\nvar __jsx = React.createElement;\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    background: url(\", \") no-repeat center center;\\n    background-size: cover;\\n    width: \", \";\\n    height: \", \";\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nimport React from 'react';\nimport styled from 'styled-components';\nvar StyledImage = styled.div(_templateObject(), function (_ref) {\n  var src = _ref.src;\n  return src;\n}, function (_ref2) {\n  var width = _ref2.width;\n  return width ? \"\".concat(width, \"px\") : '100%';\n}, function (_ref3) {\n  var height = _ref3.height;\n  return height ? \"\".concat(height, \"px\") : '100%';\n});\n\nvar Img = function Img(_ref4) {\n  var props = _extends({}, _ref4);\n\n  return __jsx(StyledImage, props);\n};\n\nexport default Img;","\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/Professional/Documents/summer-drink-main/node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nexports.__esModule = true;\nexports.useIntersection = useIntersection;\n\nvar _react = require(\"react\");\n\nvar _requestIdleCallback = require(\"./request-idle-callback\");\n\nvar hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';\n\nfunction useIntersection(_ref) {\n  var rootMargin = _ref.rootMargin,\n      disabled = _ref.disabled;\n  var isDisabled = disabled || !hasIntersectionObserver;\n  var unobserve = (0, _react.useRef)();\n\n  var _ref2 = (0, _react.useState)(false),\n      _ref3 = _slicedToArray(_ref2, 2),\n      visible = _ref3[0],\n      setVisible = _ref3[1];\n\n  var setRef = (0, _react.useCallback)(function (el) {\n    if (unobserve.current) {\n      unobserve.current();\n      unobserve.current = undefined;\n    }\n\n    if (isDisabled || visible) return;\n\n    if (el && el.tagName) {\n      unobserve.current = observe(el, function (isVisible) {\n        return isVisible && setVisible(isVisible);\n      }, {\n        rootMargin: rootMargin\n      });\n    }\n  }, [isDisabled, rootMargin, visible]);\n  (0, _react.useEffect)(function () {\n    if (!hasIntersectionObserver) {\n      if (!visible) {\n        var idleCallback = (0, _requestIdleCallback.requestIdleCallback)(function () {\n          return setVisible(true);\n        });\n        return function () {\n          return (0, _requestIdleCallback.cancelIdleCallback)(idleCallback);\n        };\n      }\n    }\n  }, [visible]);\n  return [setRef, visible];\n}\n\nfunction observe(element, callback, options) {\n  var _createObserver = createObserver(options),\n      id = _createObserver.id,\n      observer = _createObserver.observer,\n      elements = _createObserver.elements;\n\n  elements.set(element, callback);\n  observer.observe(element);\n  return function unobserve() {\n    elements.delete(element);\n    observer.unobserve(element); // Destroy observer when there's nothing left to watch:\n\n    if (elements.size === 0) {\n      observer.disconnect();\n      observers.delete(id);\n    }\n  };\n}\n\nvar observers = new Map();\n\nfunction createObserver(options) {\n  var id = options.rootMargin || '';\n  var instance = observers.get(id);\n\n  if (instance) {\n    return instance;\n  }\n\n  var elements = new Map();\n  var observer = new IntersectionObserver(function (entries) {\n    entries.forEach(function (entry) {\n      var callback = elements.get(entry.target);\n      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n\n      if (callback && isVisible) {\n        callback(isVisible);\n      }\n    });\n  }, options);\n  observers.set(id, instance = {\n    id: id,\n    observer: observer,\n    elements: elements\n  });\n  return instance;\n}"]}}